(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.GuppyDoc = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
GuppyAST = {};

GuppyAST.tokenise = function(s, tokens){
   var ans = [];
    while(s.length > 0){
	var ok = false;
	for(var i = 0; i < tokens.length; i++){
	    var t = tokens[i];
	    re = RegExp(t.re);
	    var m = re.exec(s);
	    if(m){
		m = m[0];
		s = s.substring(m.length);
		ok = true;
		if(t.type != "space") ans.push({"type":t.type, "value": t.value(m)})
		break;
	    }
	}
	if(!ok){
	    console.log("Tokenising error");
	    return [];
	}
    }
    return ans;
}

GuppyAST.tokenise_e = function(s){
    return GuppyAST.tokenise(s, [
	{"type":"number", "re":"^[0-9.]+", "value":function(m){
	    if(isNaN(Number(m))) throw Exception("Invalid number: "+m);
	    return Number(m);
	}},
	{"type":"operator", "re":"^(<=|>=|!=|>|<|=)", "value":function(m){return m}},
	{"type":"operator", "re":"^[\-+*/!]", "value":function(m){return m}},
	{"type":"name", "re":"^[a-zA-Z]", "value":function(m){return m}},
	{"type":"space", "re":"^\\s+", "value":function(m){return m}},
    ]);
 }

GuppyAST.to_eqlist = function(ast){
    comparators = ["=","!=","<=",">=","<",">"];
    if(ast[1].length == 0 || comparators.indexOf(ast[1][0][0]) < 0) return [ast];
    return GuppyAST.to_eqlist(ast[1][0]).concat([[ast[0],[ast[1][0][1][1],ast[1][1]]]]);
}

GuppyAST.to_text = function(ast){
    var functions = {};
    functions["bracket"] = function(args){return "("+args[0]+")";};
    functions["="] = function(args){return args[0]+" = "+args[1];};
    functions["!="] = function(args){return args[0]+" != "+args[1];};
    functions["<="] = function(args){return args[0]+" <= "+args[1];};
    functions[">="] = function(args){return args[0]+" >= "+args[1];};
    functions["<"] = function(args){return args[0]+" < "+args[1];};
    functions[">"] = function(args){return args[0]+" > "+args[1];};
    functions["*"] = function(args){return "("+args[0]+" * "+args[1]+")";};
    functions["+"] = function(args){return "("+args[0]+" + "+args[1]+")";};
    functions["/"] = function(args){return "("+args[0]+" / "+args[1]+")";};
    functions["fraction"] = function(args){return "("+args[0]+" / "+args[1]+")";};
    functions["-"] = function(args){return args.length == 1 ? "-"+args[0] : "("+args[0]+" - "+args[1]+")";};
    functions["val"] = function(args){return args[0]+"";};
    functions["var"] = function(args){return args[0];};
    functions["exponential"] = function(args){return "("+args[0]+"^"+args[1]+")";};
    functions["factorial"] = function(args){return "("+args[0]+")!";};
    functions["_default"] = function(name, args){return name + "(" + args.join(",") + ")";};
    return GuppyAST.eval(ast, functions);
}

GuppyAST.to_xml = function(ast, symbols, symbol_to_node){
    var prepend_str = function(doc, str){
	doc.documentElement.firstChild.textContent = str + doc.documentElement.firstChild.textContent;
    }
    var append_str = function(doc, str){
	doc.documentElement.lastChild.textContent += str;
    }
    var append_doc = function(doc, doc2){
	var n = doc.documentElement.lastChild;
	var nn = doc2.documentElement.firstChild
	n.firstChild.textContent += nn.firstChild.textContent;
	for(nn = nn.nextSibling; nn; nn = nn.nextSibling){
	    n.parentNode.insertBefore(nn.cloneNode(true),null); 
	}
    }
    var ensure_text_nodes = function(base){
	var l = base.getElementsByTagName("e");
	for(var i = 0; i < l.length; i++){
	    if(!(l[i].firstChild)) l[i].appendChild(base.createTextNode(""));
	}
    }
    var get_symbol = function(name, symbols){
	for(var s in symbols){
	    if(symbols[s].attrs.type == name) return symbols[s];
	}
    }
    var get_content_array = function(args){
	var content = {};
	for(var i = 0; i < args.length; i++){
	    content[i] = [];
	    if(args[i].documentElement.nodeName == "l") content[i].push(args[i].documentElement);
	    else for(var nn = args[i].documentElement.firstChild; nn; nn = nn.nextSibling) content[i].push(nn);
	}
	return content;
    }
    var binop_low = function(args, op, parent){
	var d = args[0].cloneNode(true);
	append_str(d, op);
	append_doc(d, args[1].cloneNode(true));
	if(parent && (parent[0] == "*" || (parent[0] == "-" && parent[1].length == 1)))
	    return make_sym("bracket", [d]);
	else
	    return d;
    }
    var binop_high = function(args, op){
	var d = args[0].cloneNode(true);
	append_doc(d, make_sym(op,[]));
	append_doc(d, args[1].cloneNode(true));
	return d;
    }
    var make_sym = function(name, args){
	var sym = get_symbol(name, symbols);
	if(!sym) throw "Unrecognised symbol: "+name;
	var base = (new window.DOMParser()).parseFromString("<c><e></e><e></e></c>", "text/xml");
	ensure_text_nodes(base);
	var e0 = base.documentElement.firstChild;
	var content = get_content_array(args);
	var f = symbol_to_node(sym, content, base)['f'];
	e0.parentNode.insertBefore(f,e0.nextSibling);
	ensure_text_nodes(base);
	return base;
    }
    var functions = {};

    var ops = ["*","<",">","=","<=",">=","!="];
    for(var i = 0; i < ops.length; i++){
	functions[ops[i]] = function(o){ return function(args){ return binop_high(args, o); }}(ops[i]);
    }
    // functions["*"] = function(args){
    // 	return binop_high(args, "*");
    // };
    functions["/"] = function(args){
	return make_sym("frac",args);
    };
    functions["+"] = function(args, parent){ return binop_low(args, "+", parent); };
    functions["-"] = function(args, parent){
	if(args.length == 1){ var d = args[0].cloneNode(true); prepend_str(d, "-"); return d; }
	else{ return binop_low(args, "-", parent);};
    }
    functions["val"] = function(args){ return (new window.DOMParser()).parseFromString("<c><e>" + args[0] + "</e></c>", "text/xml");};
    functions["var"] = function(args){ return (new window.DOMParser()).parseFromString("<c><e>" + args[0] + "</e></c>", "text/xml");};
    functions["list"] = function(args){
	var base = (new window.DOMParser()).parseFromString("<l></l>", "text/xml");
	for(var i = 0; i < args.length; i++){
	    base.documentElement.appendChild(args[i].documentElement.cloneNode(true));
	}
	base.documentElement.firstChild.setAttribute("s",String(args.length))
	return base;
    };
    // var comparators = {"<":"less",">":"greater","=":"eq","!=":"neq",">=":"geq","<=":"leq"};
    // for(var c in comparators){
    // 	functions[c] = function(args){
    // 	    return make_sym(comparators[c], args);
    // 	}
    // }
    functions["_default"] = function(name, args){
	return make_sym(name, args);
    }
    var ans = GuppyAST.eval(ast, functions);
    var new_base = (new window.DOMParser()).parseFromString("<m></m>", "text/xml");
    for(nn = ans.documentElement.firstChild; nn; nn = nn.nextSibling){
	new_base.documentElement.insertBefore(nn.cloneNode(true),null);
    }
    return new_base;

}

GuppyAST.get_nodes = function(ast, name){
    if(ast.length < 2) return [];
    var ans = [];
    if(ast[0] == name) ans.push(ast[1]);
    if(ast[0] == "var" || ast[0] == "val") return ans;
    for(var i = 0; i < ast[1].length; i++) ans = ans.concat(GuppyAST.get_nodes(ast[1][i], name));
    return ans;
}

GuppyAST.get_vars = function(ast){
    var vars = {};
    var ans = [];
    var l = GuppyAST.get_nodes(ast, "var");
    for(var i = 0; i < l.length; i++) vars[l[i][0]] = true;
    for(var x in vars) ans.push(x);
    return ans;
}

GuppyAST.to_function = function(ast, functions){
    functions = functions || {}
    defaults = {}
    defaults["*"] = function(args){return function(vars){return args[0](vars)*args[1](vars)};};
    defaults["+"] = function(args){return function(vars){return args[0](vars)+args[1](vars)};};
    defaults["/"] = function(args){return function(vars){return args[0](vars)/args[1](vars)};};
    defaults["-"] = function(args){return args.length == 1 ? function(vars){return -args[0](vars)} : function(vars){return args[0](vars)-args[1](vars)};};
    defaults["val"] = function(args){return function(vars){ return args[0]; };};
    defaults["var"] = function(args){return function(vars){ if(args[0] == "pi") return Math.PI; if(args[0] == "e") return Math.E; return vars[args[0]]; };};
    defaults["exponential"] = function(args){return function(vars){return args[0](vars)**args[1](vars)};};
    //defaults["fraction"] = function(args){return function(vars){return args[0](vars)/args[1](vars);};}
    defaults["square_root"] = function(args){return function(vars){return Math.sqrt(args[0](vars))};};
    defaults["sin"] = function(args){return function(vars){return Math.sin(args[0](vars))};};
    defaults["cos"] = function(args){return function(vars){return Math.cos(args[0](vars))};};
    defaults["tan"] = function(args){return function(vars){return Math.tan(args[0](vars))};};
    defaults["log"] = function(args){return function(vars){return Math.log(args[0](vars))};};
    for(var n in defaults) if(!functions[n]) functions[n] = defaults[n];
    return {"function":GuppyAST.eval(ast, functions),"vars":GuppyAST.get_vars(ast)};
}

GuppyAST.eval = function(ast, functions, parent){
    ans = null;
    if(!functions["_default"]) functions["_default"] = function(name, args){ throw "Function not implemented: " + name;}
    
    var args = []
    for(var i = 0; i < ast[1].length; i++){
	if(Object.prototype.toString.call(ast[1][i]) === '[object Array]'){
	    args.push(GuppyAST.eval(ast[1][i], functions, ast));
	}
	else{
	    args.push(ast[1][i]);
	}
    }
    //console.log("Fn",ast[0],functions[ast[0]]);
    if(functions[ast[0]]) ans = functions[ast[0]](args, parent);
    else if(functions["_default"]) ans = functions["_default"](ast[0], args, parent);
    
    //console.log("EVAL",JSON.stringify(ast),'=',ans);
    return ans
}

GuppyAST.parse_e = function(tokens){
    var symbol_table = {};

    var original_symbol = {
	nud: function () { throw Error("Undefined"); },
	led: function (left) { throw Error("Missing operator"); }
    };

    var mul = function(left){ return ["*", [left, this.nud()]]; };
    
    var symbol = function (id, bp) {
	var s = symbol_table[id];
	bp = bp || 0;
	if (s) {
            if (bp >= s.lbp) {
		s.lbp = bp;
            }
	} else {
            s = Object.create(original_symbol);
            s.id = s.value = id;
            s.lbp = bp;
            symbol_table[id] = s;
	}
	return s;
    };

    symbol("(end)");

    s = symbol("(blank)", 60);
    s.nud = function(){ return ["blank"];};
    
    s = symbol("(function)", 60);
    s.led = mul;
    //s.nud = function(){ return [this.value, this.args || [], this.kwargs || {}];};
    s.nud = function(){ return [this.value, this.args || []];};
    
    s = symbol("(literal)", 60);
    s.led = mul;
    s.nud = function(){ return ["val", [this.value]] };

    s = symbol("(pass)", 60);
    s.led = mul;
    s.nud = function(){ return this.args[0] };
    
    s = symbol("(var)", 60);
    s.led = mul;
    s.nud = function(){ return ["var", [this.value]] };

    var token;
    var token_nr = 0;

    var advance = function (id) {
	var a, o, t, v;
	if (id && token.id !== id) {
            throw Error("Expected '" + id + "'");
	}
	if (token_nr >= tokens.length) {
            token = symbol_table["(end)"];
            return;
	}
	t = tokens[token_nr];
	token_nr += 1;
	v = t.value;
	var args = null;
	var kwargs = null;
	a = t.type;
	if (a === "name") {
            o = symbol_table["(var)"];
	} else if (a === "operator") {
            o = symbol_table[v];
            if (!o) {
		throw Exception("Unknown operator.");
            }
	} else if (a ===  "pass") {
            a = "pass";
            o = symbol_table["(pass)"];
	    args = t.args;
	} else if (a ===  "number") {
            a = "literal";
            o = symbol_table["(literal)"];
	} else if (a ===  "function") {
            a = "function";
            o = symbol_table["(function)"];
	    args = t.args;
	    kwargs = t.kwargs;
	} else {
            throw Error("Unexpected token",t);
	}
	token = Object.create(o);
	token.type = a;
	token.value = v;
	if(args) token.args = args;
	if(kwargs) token.kwargs = kwargs;
	return token;
    };


    var expression = function (rbp) {
	var left;
	var t = token;
	advance();
	left = t.nud();
	while (rbp < token.lbp) {
            t = token;
            advance();
            left = t.led(left);
	}
	return left;
    };

    var infix = function (id, bp, led) {
	var s = symbol(id, bp);
	s.led = led || function (left) {
            return [this.value, [left, expression(bp)]];
	};
	return s;
    }

    
    infix("=", 40);
    infix("!=", 40);
    infix("<", 40);
    infix(">", 40);
    infix("<=", 40);
    infix(">=", 40);

    infix("+", 50);
    infix("-", 50);
    infix("*", 60);
    infix("/", 60);
    var prefix = function (id, nud) {
	var s = symbol(id);
	s.nud = nud || function () {
            return [this.value, [expression(70)]];
	};
	return s;
    }

    prefix("-");
    prefix("!");
    prefix("typeof");

    if(tokens.length == 0) return ["blank"];
    
    advance();
    
    return expression(10);
}



GuppyAST.tokenise_text = function(s){
    return GuppyAST.tokenise(s, [
	{"type":"number", "re":"^[0-9.]+", "value":function(m){return Number(m)}},
	{"type":"operator", "re":"^(!=|>=|<=)", "value":function(m){return m;}},
	{"type":"operator", "re":"^[\-+*/,!^()=<>]", "value":function(m){return m}},
	{"type":"name", "re":"^[a-zA-Z_]+", "value":function(m){return m}},
	{"type":"comma", "re":"^,", "value":function(m){return m}},
	{"type":"space", "re":"^\\s+", "value":function(m){return m}},
    ]);
}

GuppyAST.parse_text = function(tokens){
    var symbol_table = {};

    var original_symbol = {
	nud: function () { throw Error("Undefined"); },
	led: function (left) { throw Error("Missing operator"); }
    };

    var mul = function(left){ return ["*", [left, this.nud()]]; };
    
    var symbol = function (id, bp) {
	var s = symbol_table[id];
	bp = bp || 0;
	if (s) {
            if (bp >= s.lbp) {
		s.lbp = bp;
            }
	} else {
            s = Object.create(original_symbol);
            s.id = s.value = id;
            s.lbp = bp;
            symbol_table[id] = s;
	}
	return s;
    };

    symbol("(end)");

    s = symbol("(blank)", 60);
    s.nud = function(){ return ["blank"];};
    
    s = symbol("(literal)", 60);
    s.led = mul;
    s.nud = function(){ return ["val", [this.value]] };

    var get_args = function(){
	var args = [];
	advance()
	if(token.id !== ")"){
	    while(true){
		args.push(expression(0));
		if (token.id !== ",") {
		    break;
		}
		advance(",");
	    }
	}
	advance(")");
	return args;
    }
    
    s = symbol("(var)", 60);
    s.led = mul;
    s.nud = function(){
	if(token.id == "("){
	    return [this.value, get_args()];
	}
	else{
	    return ["var", [this.value]]
	}
    };
    
    var token;
    var token_nr = 0;

    var advance = function (id) {
	var a, o, t, v;
	if (id && token.id !== id) {
            throw Error("Expected '" + id + "'");
	}
	if (token_nr >= tokens.length) {
            token = symbol_table["(end)"];
            return;
	}
	t = tokens[token_nr];
	token_nr += 1;
	v = t.value;
	var args = null;
	var kwargs = null;
	a = t.type;
	if (a === "name") {
            o = symbol_table["(var)"];
	} else if (a === "operator") {
            o = symbol_table[v];
            if (!o) {
		throw Error("Unknown operator.");
            }
	} else if (a ===  "number") {
            a = "literal";
            o = symbol_table["(literal)"];
	} else {
            throw Error("Unexpected token",t);
	}
	token = Object.create(o);
	token.type = a;
	token.value = v;
	if(args) token.args = args;
	//console.log("ADVD",JSON.stringify(token));
	return token;
    };


    var expression = function (rbp) {
	var left;
	var t = token;
	//console.log("T1",JSON.stringify(token));
	advance();
	//console.log("T2",JSON.stringify(token));
	left = t.nud();
	while (rbp < token.lbp) {
            t = token;
            advance();
	    //console.log("RB",JSON.stringify(token));
            left = t.led(left);
	}
	//console.log("POW", rbp, token.id, token.lbp);
	return left;
    };

    var infix = function (id, bp, led) {
	var s = symbol(id, bp);
	s.led = led || function (left) {
            return [this.value, [left, expression(bp)]];
	};
	return s;
    }

    infix("=", 40);
    infix("!=", 40);
    infix("<", 40);
    infix(">", 40);
    infix("<=", 40);
    infix(">=", 40);

    infix("+", 50);
    infix("-", 50);
    infix("*", 60);
    infix("/", 60);
    
    infix("!", 70, function(left){
	return ["factorial", [left]];
    });
    
    infix("^", 70, function(left){
	return ["exponential", [left, expression(70)]];
    });
    
    infix("(", 80, mul);

    symbol("(").nud = function(){
	var ans = expression(0);
	advance(")");
	return ans;
    }
    symbol(")");
    symbol(",");
    
    var prefix = function (id, nud) {
	var s = symbol(id);
	s.nud = nud || function () {
            return [this.value, [expression(70)]];
	};
	return s;
    }

    prefix("-");

    if(tokens.length == 0) return ["blank"];
    
    advance();
    
    return expression(10);
}

module.exports = GuppyAST;

},{}],2:[function(require,module,exports){
GuppyAST = require('./guppy_ast.js');

/**
   @class
   @classdesc A class representing a Guppy document
   @param {string} [doc=<m><e></e></m>] - An XML string representing the document
   @constructor 
 */
var GuppyDoc = function(doc){
    doc = doc || "<m><e></e></m>";
    this.set_content(doc);
}

GuppyDoc.prototype.is_small = function(nn){
    var n = nn.parentNode;
    while(n != null && n.nodeName != 'm'){
	if(n.getAttribute("small") == "yes") return true;
	n = n.parentNode
	while(n != null && n.nodeName != 'c') n = n.parentNode;
    }
    return false;
}

GuppyDoc.prototype.ensure_text_nodes = function(){
    var l = this.base.getElementsByTagName("e");
    for(var i = 0; i < l.length; i++){
	if(!(l[i].firstChild)) l[i].appendChild(this.base.createTextNode(""));
    }
}

/** 
    Check if document is empty
    @memberof GuppyDoc
    @returns {boolean}
*/
GuppyDoc.prototype.is_blank = function(){
    if(this.base.getElementsByTagName("f").length > 0) return false;
    var l = this.base.getElementsByTagName("e");
    if(l.length == 1 && (!(l[0].firstChild) || l[0].firstChild.textContent == "")) return true;
    return false;
}


/** 
    Get the document as a DOM object
    @memberof GuppyDoc
    @returns {Element}
*/
GuppyDoc.prototype.root = function(){
    return this.base.documentElement;
}

/** 
    Get the content of the document as a string
    @memberof GuppyDoc
    @param {string} t - The rendering method to use ("latex", "text", "ast" (for syntax tree), or "xml" (for internal XML representation))
    @returns {string}
*/
GuppyDoc.prototype.get_content = function(t,r){
    if(t == "xml") return (new XMLSerializer()).serializeToString(this.base);
    else if(t == "ast") return JSON.stringify(this.syntax_tree());
    else if(t == "text") return GuppyAST.to_text(this.syntax_tree());
    else if(t == "function") return GuppyAST.to_function(this.syntax_tree());
    else if(t == "eqns") return GuppyAST.to_eqlist(this.syntax_tree());
    else return this.manual_render(t,this.root(),r);
}

GuppyDoc.prototype.import_text = function(text, syms, s2n){
    var tokens = GuppyAST.tokenise_text(text);
    console.log("TOKENS",JSON.stringify(tokens));
    var ast = GuppyAST.parse_text(tokens);
    console.log("AST",JSON.stringify(ast));
    this.import_ast(ast, syms, s2n);
}

GuppyDoc.prototype.import_ast = function(ast, syms, s2n){
    syms = syms || GuppySymbols.symbols;
    s2n = s2n || GuppySymbols.symbol_to_node;
    var doc = GuppyAST.to_xml(ast, syms, s2n);
    this.base = doc;
    this.ensure_text_nodes();
}

GuppyDoc.prototype.syntax_tree = function(n){
    n = n || this.root()
    if(n.nodeName == "e"){
	console.log("Should never happen");
	//ans = n.firstChild.textContent;
    }
    else if(n.nodeName == "f"){
	var ans = {"args":[], "kwargs":{}};
	ans['value'] = n.getAttribute("type");
	ans['type'] = "function";
	if(n.hasAttribute("ast_value")) ans['value'] = n.getAttribute("ast_value");
	if(n.hasAttribute("ast_type")) ans['type'] = n.getAttribute("ast_type");
	else if(n.getAttribute("char") == "yes") ans['type'] = "name";
	
	var iterator = this.xpath_list("./*[name()='c' or name()='l']", n)
	for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext()){
	    //if(nn.hasAttribute("name")) ans.kwargs[nn.getAttribute("name")] = this.syntax_tree(nn)
	    //else ans.args.push(this.syntax_tree(nn))
	    ans.args.push(this.syntax_tree(nn))
	}
	//console.log("F",JSON.stringify(ans))
    }
    else if(n.nodeName == "l"){
	ans = [];
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    ans.push(this.syntax_tree(nn));
	}
	ans = ["list",ans];
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
	if(n.hasAttribute("mode") && n.getAttribute("mode") == "text"){
	    ans = n.firstChild.firstChild.textContent;
	}
	else{
	    var tokens = []
	    for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
		if(nn.nodeName == "e"){
		    tokens = tokens.concat(GuppyAST.tokenise_e(nn.firstChild.textContent));
		}
		else if(nn.nodeName == "f"){
		    tokens.push(this.syntax_tree(nn));
		}
	    }
	    //console.log("TOK",tokens);
	    ans = GuppyAST.parse_e(tokens);
	}
    }
    return ans;
}

GuppyDoc.prototype.xpath_node = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null).singleNodeValue;
}

GuppyDoc.prototype.xpath_list = function(xpath, node){
    node = node || this.root()
    return this.base.evaluate(xpath, node, null, XPathResult.ORDERED_NODE_ITERATOR_TYPE, null);
}

/** 
    Get the names of symbols used in this document
    @memberof GuppyDoc
    @param {string[]} [groups] - A list of groups you want strings for
    @returns {string[]}
*/
GuppyDoc.prototype.get_symbols = function(groups){
    var types = {};
    var ans = [];
    var iterator = groups ? this.xpath_list("//f") : this.xpath_list("//f[@group='"+groups[i]+"']");
    for(var nn = iterator.iterateNext(); nn != null; nn = iterator.iterateNext())
	types[nn.getAttribute("type")] = true;
    for(var t in types)
	ans.push(t);
    return ans;
}

/** 
    Set the content of the document
    @memberof GuppyDoc
    @param {string} xml_data - An XML string representing the content of the document
*/
GuppyDoc.prototype.set_content = function(xml_data){
    this.base = (new window.DOMParser()).parseFromString(xml_data, "text/xml");
    this.ensure_text_nodes();
}

GuppyDoc.bracket_xpath = "(count(./*) != 1 and not \
		          ( \
                            count(./e)=2 and \
			    count(./f)=1 and \
			    count(./e[string-length(text())=0])=2 and \
			    ( \
			      (\
                                count(./f/c)=1 and\
			        count(./f/c[@is_bracket='yes'])=1\
			      )\
			      or\
			      (\
			        f/@char='yes' and \
				count(./e[@current='yes'])=0 and \
				count(./e[@temp='yes'])=0 \
			      )\
			    )\
			  )\
			)  \
			or\
		        (\
			  count(./*) = 1 and \
			  string-length(./e/text()) != 1 and \
			  number(./e/text()) != ./e/text() \
			) \
			or \
		        ( \
			  count(./*) = 1 and \
			  ./e/@current = 'yes' \
			) \
			or \
		        ( \
			  count(./*) = 1 and \
			  ./e/@temp = 'yes' \
			)"

GuppyDoc.prototype.manual_render = function(t,n,r){
    var ans = "";
    if(n.nodeName == "e"){
	if(t == "latex" && r){
	    ans = n.getAttribute("render");
	}
	else if(t == "text"){
	    ans = n.firstChild.textContent;
	    if(n.previousSibling && n.nextSibling && ans == "")
		ans = " * ";
	    else {
		ans = ans.replace(/(.)([^a-zA-Z0-9.])(.)/g,"$1 $2 $3");
		ans = ans.replace(/([a-zA-Z])(?=\.)/g,"$1 * ");
		ans = ans.replace(/(\.)(?=[a-zA-Z])/g,"$1 * ");
		ans = ans.replace(/([a-zA-Z])(?=[a-zA-Z0-9])/g,"$1 * ");
		ans = ans.replace(/([a-zA-Z0-9])(?=[a-zA-Z])/g,"$1 * ");
		if(n.previousSibling && n.previousSibling.getAttribute("group") != "operations") ans = ans.replace(/^([a-zA-Z0-9])/g," * $1");
		if(n.nextSibling && n.nextSibling.getAttribute("group") != "operations") ans = ans.replace(/([a-zA-Z0-9])$/g,"$1 * ");
		ans = " "+ans+" ";
	    }
	}
	else{
	    ans = n.firstChild.textContent;
	}
    }
    else if(n.nodeName == "f"){
	var real_type = (t == "latex" && this.is_small(n)) ? "small_latex" : t;
	var nn = this.xpath_node("./b[@p='"+real_type+"']", n) || this.xpath_node("./b[@p='"+t+"']", n);
	if(nn) ans = this.manual_render(t,nn,r);
    }
    else if(n.nodeName == "b"){
	var cs = []
	var i = 1;
	var par = n.parentNode;
	for(var nn = par.firstChild; nn != null; nn = nn.nextSibling)
	    if(nn.nodeName == "c" || nn.nodeName == "l") cs[i++] = this.manual_render(t,nn,r);
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    if(nn.nodeType == 3) ans += nn.textContent;
	    else if(nn.nodeType == 1){
		if(nn.hasAttribute("d")){
		    var dim = parseInt(nn.getAttribute("d"));
		    var joiner = function(d,l){
			if(d > 1) for(var k = 0; k < l.length; k++) l[k] = joiner(d-1,l[k]);
			return l.join(nn.getAttribute('sep'+(d-1)));
		    }
		    ans += joiner(dim,cs[parseInt(nn.getAttribute("ref"))]);
		}
		else ans += cs[parseInt(nn.getAttribute("ref"))];
	    }
	}
    }
    else if(n.nodeName == "l"){
	ans = [];
	var i = 0;
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling){
	    ans[i++] = this.manual_render(t,nn,r);
	}
    }
    else if(n.nodeName == "c" || n.nodeName == "m"){
	for(var nn = n.firstChild; nn != null; nn = nn.nextSibling)
	    ans += this.manual_render(t,nn,r);
	if(t == "latex" &&
           n.getAttribute("bracket") == "yes" &&
	   this.base.evaluate(GuppyDoc.bracket_xpath, n, null,
			 XPathResult.BOOLEAN_TYPE, null).booleanValue){ 
	    ans = "\\left("+ans+"\\right)";
	}
    }
    return ans;
}

GuppyDoc.prototype.path_to = function(n){
    var name = n.nodeName;
    if(name == "m") return "guppy_loc_m";
    var ns = 0;
    for(var nn = n; nn != null; nn = nn.previousSibling) if(nn.nodeType == 1 && nn.nodeName == name) ns++;
    return this.path_to(n.parentNode)+"_"+name+""+ns;
}

module.exports = GuppyDoc;

},{"./guppy_ast.js":1}]},{},[2])(2)
});
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Vzci9saWIvbm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2Jyb3dzZXItcGFjay9fcHJlbHVkZS5qcyIsInNyYy9ndXBweV9hc3QuanMiLCJzcmMvZ3VwcHlfZG9jLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWpCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIkd1cHB5QVNUID0ge307XG5cbkd1cHB5QVNULnRva2VuaXNlID0gZnVuY3Rpb24ocywgdG9rZW5zKXtcbiAgIHZhciBhbnMgPSBbXTtcbiAgICB3aGlsZShzLmxlbmd0aCA+IDApe1xuXHR2YXIgb2sgPSBmYWxzZTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGg7IGkrKyl7XG5cdCAgICB2YXIgdCA9IHRva2Vuc1tpXTtcblx0ICAgIHJlID0gUmVnRXhwKHQucmUpO1xuXHQgICAgdmFyIG0gPSByZS5leGVjKHMpO1xuXHQgICAgaWYobSl7XG5cdFx0bSA9IG1bMF07XG5cdFx0cyA9IHMuc3Vic3RyaW5nKG0ubGVuZ3RoKTtcblx0XHRvayA9IHRydWU7XG5cdFx0aWYodC50eXBlICE9IFwic3BhY2VcIikgYW5zLnB1c2goe1widHlwZVwiOnQudHlwZSwgXCJ2YWx1ZVwiOiB0LnZhbHVlKG0pfSlcblx0XHRicmVhaztcblx0ICAgIH1cblx0fVxuXHRpZighb2spe1xuXHQgICAgY29uc29sZS5sb2coXCJUb2tlbmlzaW5nIGVycm9yXCIpO1xuXHQgICAgcmV0dXJuIFtdO1xuXHR9XG4gICAgfVxuICAgIHJldHVybiBhbnM7XG59XG5cbkd1cHB5QVNULnRva2VuaXNlX2UgPSBmdW5jdGlvbihzKXtcbiAgICByZXR1cm4gR3VwcHlBU1QudG9rZW5pc2UocywgW1xuXHR7XCJ0eXBlXCI6XCJudW1iZXJcIiwgXCJyZVwiOlwiXlswLTkuXStcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe1xuXHQgICAgaWYoaXNOYU4oTnVtYmVyKG0pKSkgdGhyb3cgRXhjZXB0aW9uKFwiSW52YWxpZCBudW1iZXI6IFwiK20pO1xuXHQgICAgcmV0dXJuIE51bWJlcihtKTtcblx0fX0sXG5cdHtcInR5cGVcIjpcIm9wZXJhdG9yXCIsIFwicmVcIjpcIl4oPD18Pj18IT18Pnw8fD0pXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuXHR7XCJ0eXBlXCI6XCJvcGVyYXRvclwiLCBcInJlXCI6XCJeW1xcLSsqLyFdXCIsIFwidmFsdWVcIjpmdW5jdGlvbihtKXtyZXR1cm4gbX19LFxuXHR7XCJ0eXBlXCI6XCJuYW1lXCIsIFwicmVcIjpcIl5bYS16QS1aXVwiLCBcInZhbHVlXCI6ZnVuY3Rpb24obSl7cmV0dXJuIG19fSxcblx0e1widHlwZVwiOlwic3BhY2VcIiwgXCJyZVwiOlwiXlxcXFxzK1wiLCBcInZhbHVlXCI6ZnVuY3Rpb24obSl7cmV0dXJuIG19fSxcbiAgICBdKTtcbiB9XG5cbkd1cHB5QVNULnRvX2VxbGlzdCA9IGZ1bmN0aW9uKGFzdCl7XG4gICAgY29tcGFyYXRvcnMgPSBbXCI9XCIsXCIhPVwiLFwiPD1cIixcIj49XCIsXCI8XCIsXCI+XCJdO1xuICAgIGlmKGFzdFsxXS5sZW5ndGggPT0gMCB8fCBjb21wYXJhdG9ycy5pbmRleE9mKGFzdFsxXVswXVswXSkgPCAwKSByZXR1cm4gW2FzdF07XG4gICAgcmV0dXJuIEd1cHB5QVNULnRvX2VxbGlzdChhc3RbMV1bMF0pLmNvbmNhdChbW2FzdFswXSxbYXN0WzFdWzBdWzFdWzFdLGFzdFsxXVsxXV1dXSk7XG59XG5cbkd1cHB5QVNULnRvX3RleHQgPSBmdW5jdGlvbihhc3Qpe1xuICAgIHZhciBmdW5jdGlvbnMgPSB7fTtcbiAgICBmdW5jdGlvbnNbXCJicmFja2V0XCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCIpXCI7fTtcbiAgICBmdW5jdGlvbnNbXCI9XCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGFyZ3NbMF0rXCIgPSBcIithcmdzWzFdO307XG4gICAgZnVuY3Rpb25zW1wiIT1cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJnc1swXStcIiAhPSBcIithcmdzWzFdO307XG4gICAgZnVuY3Rpb25zW1wiPD1cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJnc1swXStcIiA8PSBcIithcmdzWzFdO307XG4gICAgZnVuY3Rpb25zW1wiPj1cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJnc1swXStcIiA+PSBcIithcmdzWzFdO307XG4gICAgZnVuY3Rpb25zW1wiPFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdK1wiIDwgXCIrYXJnc1sxXTt9O1xuICAgIGZ1bmN0aW9uc1tcIj5cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJnc1swXStcIiA+IFwiK2FyZ3NbMV07fTtcbiAgICBmdW5jdGlvbnNbXCIqXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCIgKiBcIithcmdzWzFdK1wiKVwiO307XG4gICAgZnVuY3Rpb25zW1wiK1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiICsgXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcIi9cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gXCIoXCIrYXJnc1swXStcIiAvIFwiK2FyZ3NbMV0rXCIpXCI7fTtcbiAgICBmdW5jdGlvbnNbXCJmcmFjdGlvblwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiIC8gXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcIi1cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJncy5sZW5ndGggPT0gMSA/IFwiLVwiK2FyZ3NbMF0gOiBcIihcIithcmdzWzBdK1wiIC0gXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcInZhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBhcmdzWzBdK1wiXCI7fTtcbiAgICBmdW5jdGlvbnNbXCJ2YXJcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gYXJnc1swXTt9O1xuICAgIGZ1bmN0aW9uc1tcImV4cG9uZW50aWFsXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIFwiKFwiK2FyZ3NbMF0rXCJeXCIrYXJnc1sxXStcIilcIjt9O1xuICAgIGZ1bmN0aW9uc1tcImZhY3RvcmlhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBcIihcIithcmdzWzBdK1wiKSFcIjt9O1xuICAgIGZ1bmN0aW9uc1tcIl9kZWZhdWx0XCJdID0gZnVuY3Rpb24obmFtZSwgYXJncyl7cmV0dXJuIG5hbWUgKyBcIihcIiArIGFyZ3Muam9pbihcIixcIikgKyBcIilcIjt9O1xuICAgIHJldHVybiBHdXBweUFTVC5ldmFsKGFzdCwgZnVuY3Rpb25zKTtcbn1cblxuR3VwcHlBU1QudG9feG1sID0gZnVuY3Rpb24oYXN0LCBzeW1ib2xzLCBzeW1ib2xfdG9fbm9kZSl7XG4gICAgdmFyIHByZXBlbmRfc3RyID0gZnVuY3Rpb24oZG9jLCBzdHIpe1xuXHRkb2MuZG9jdW1lbnRFbGVtZW50LmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgPSBzdHIgKyBkb2MuZG9jdW1lbnRFbGVtZW50LmZpcnN0Q2hpbGQudGV4dENvbnRlbnQ7XG4gICAgfVxuICAgIHZhciBhcHBlbmRfc3RyID0gZnVuY3Rpb24oZG9jLCBzdHIpe1xuXHRkb2MuZG9jdW1lbnRFbGVtZW50Lmxhc3RDaGlsZC50ZXh0Q29udGVudCArPSBzdHI7XG4gICAgfVxuICAgIHZhciBhcHBlbmRfZG9jID0gZnVuY3Rpb24oZG9jLCBkb2MyKXtcblx0dmFyIG4gPSBkb2MuZG9jdW1lbnRFbGVtZW50Lmxhc3RDaGlsZDtcblx0dmFyIG5uID0gZG9jMi5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZFxuXHRuLmZpcnN0Q2hpbGQudGV4dENvbnRlbnQgKz0gbm4uZmlyc3RDaGlsZC50ZXh0Q29udGVudDtcblx0Zm9yKG5uID0gbm4ubmV4dFNpYmxpbmc7IG5uOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcblx0ICAgIG4ucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUobm4uY2xvbmVOb2RlKHRydWUpLG51bGwpOyBcblx0fVxuICAgIH1cbiAgICB2YXIgZW5zdXJlX3RleHRfbm9kZXMgPSBmdW5jdGlvbihiYXNlKXtcblx0dmFyIGwgPSBiYXNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZVwiKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspe1xuXHQgICAgaWYoIShsW2ldLmZpcnN0Q2hpbGQpKSBsW2ldLmFwcGVuZENoaWxkKGJhc2UuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xuXHR9XG4gICAgfVxuICAgIHZhciBnZXRfc3ltYm9sID0gZnVuY3Rpb24obmFtZSwgc3ltYm9scyl7XG5cdGZvcih2YXIgcyBpbiBzeW1ib2xzKXtcblx0ICAgIGlmKHN5bWJvbHNbc10uYXR0cnMudHlwZSA9PSBuYW1lKSByZXR1cm4gc3ltYm9sc1tzXTtcblx0fVxuICAgIH1cbiAgICB2YXIgZ2V0X2NvbnRlbnRfYXJyYXkgPSBmdW5jdGlvbihhcmdzKXtcblx0dmFyIGNvbnRlbnQgPSB7fTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xuXHQgICAgY29udGVudFtpXSA9IFtdO1xuXHQgICAgaWYoYXJnc1tpXS5kb2N1bWVudEVsZW1lbnQubm9kZU5hbWUgPT0gXCJsXCIpIGNvbnRlbnRbaV0ucHVzaChhcmdzW2ldLmRvY3VtZW50RWxlbWVudCk7XG5cdCAgICBlbHNlIGZvcih2YXIgbm4gPSBhcmdzW2ldLmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkOyBubjsgbm4gPSBubi5uZXh0U2libGluZykgY29udGVudFtpXS5wdXNoKG5uKTtcblx0fVxuXHRyZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgdmFyIGJpbm9wX2xvdyA9IGZ1bmN0aW9uKGFyZ3MsIG9wLCBwYXJlbnQpe1xuXHR2YXIgZCA9IGFyZ3NbMF0uY2xvbmVOb2RlKHRydWUpO1xuXHRhcHBlbmRfc3RyKGQsIG9wKTtcblx0YXBwZW5kX2RvYyhkLCBhcmdzWzFdLmNsb25lTm9kZSh0cnVlKSk7XG5cdGlmKHBhcmVudCAmJiAocGFyZW50WzBdID09IFwiKlwiIHx8IChwYXJlbnRbMF0gPT0gXCItXCIgJiYgcGFyZW50WzFdLmxlbmd0aCA9PSAxKSkpXG5cdCAgICByZXR1cm4gbWFrZV9zeW0oXCJicmFja2V0XCIsIFtkXSk7XG5cdGVsc2Vcblx0ICAgIHJldHVybiBkO1xuICAgIH1cbiAgICB2YXIgYmlub3BfaGlnaCA9IGZ1bmN0aW9uKGFyZ3MsIG9wKXtcblx0dmFyIGQgPSBhcmdzWzBdLmNsb25lTm9kZSh0cnVlKTtcblx0YXBwZW5kX2RvYyhkLCBtYWtlX3N5bShvcCxbXSkpO1xuXHRhcHBlbmRfZG9jKGQsIGFyZ3NbMV0uY2xvbmVOb2RlKHRydWUpKTtcblx0cmV0dXJuIGQ7XG4gICAgfVxuICAgIHZhciBtYWtlX3N5bSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3Mpe1xuXHR2YXIgc3ltID0gZ2V0X3N5bWJvbChuYW1lLCBzeW1ib2xzKTtcblx0aWYoIXN5bSkgdGhyb3cgXCJVbnJlY29nbmlzZWQgc3ltYm9sOiBcIituYW1lO1xuXHR2YXIgYmFzZSA9IChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoXCI8Yz48ZT48L2U+PGU+PC9lPjwvYz5cIiwgXCJ0ZXh0L3htbFwiKTtcblx0ZW5zdXJlX3RleHRfbm9kZXMoYmFzZSk7XG5cdHZhciBlMCA9IGJhc2UuZG9jdW1lbnRFbGVtZW50LmZpcnN0Q2hpbGQ7XG5cdHZhciBjb250ZW50ID0gZ2V0X2NvbnRlbnRfYXJyYXkoYXJncyk7XG5cdHZhciBmID0gc3ltYm9sX3RvX25vZGUoc3ltLCBjb250ZW50LCBiYXNlKVsnZiddO1xuXHRlMC5wYXJlbnROb2RlLmluc2VydEJlZm9yZShmLGUwLm5leHRTaWJsaW5nKTtcblx0ZW5zdXJlX3RleHRfbm9kZXMoYmFzZSk7XG5cdHJldHVybiBiYXNlO1xuICAgIH1cbiAgICB2YXIgZnVuY3Rpb25zID0ge307XG5cbiAgICB2YXIgb3BzID0gW1wiKlwiLFwiPFwiLFwiPlwiLFwiPVwiLFwiPD1cIixcIj49XCIsXCIhPVwiXTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgb3BzLmxlbmd0aDsgaSsrKXtcblx0ZnVuY3Rpb25zW29wc1tpXV0gPSBmdW5jdGlvbihvKXsgcmV0dXJuIGZ1bmN0aW9uKGFyZ3MpeyByZXR1cm4gYmlub3BfaGlnaChhcmdzLCBvKTsgfX0ob3BzW2ldKTtcbiAgICB9XG4gICAgLy8gZnVuY3Rpb25zW1wiKlwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe1xuICAgIC8vIFx0cmV0dXJuIGJpbm9wX2hpZ2goYXJncywgXCIqXCIpO1xuICAgIC8vIH07XG4gICAgZnVuY3Rpb25zW1wiL1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe1xuXHRyZXR1cm4gbWFrZV9zeW0oXCJmcmFjXCIsYXJncyk7XG4gICAgfTtcbiAgICBmdW5jdGlvbnNbXCIrXCJdID0gZnVuY3Rpb24oYXJncywgcGFyZW50KXsgcmV0dXJuIGJpbm9wX2xvdyhhcmdzLCBcIitcIiwgcGFyZW50KTsgfTtcbiAgICBmdW5jdGlvbnNbXCItXCJdID0gZnVuY3Rpb24oYXJncywgcGFyZW50KXtcblx0aWYoYXJncy5sZW5ndGggPT0gMSl7IHZhciBkID0gYXJnc1swXS5jbG9uZU5vZGUodHJ1ZSk7IHByZXBlbmRfc3RyKGQsIFwiLVwiKTsgcmV0dXJuIGQ7IH1cblx0ZWxzZXsgcmV0dXJuIGJpbm9wX2xvdyhhcmdzLCBcIi1cIiwgcGFyZW50KTt9O1xuICAgIH1cbiAgICBmdW5jdGlvbnNbXCJ2YWxcIl0gPSBmdW5jdGlvbihhcmdzKXsgcmV0dXJuIChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoXCI8Yz48ZT5cIiArIGFyZ3NbMF0gKyBcIjwvZT48L2M+XCIsIFwidGV4dC94bWxcIik7fTtcbiAgICBmdW5jdGlvbnNbXCJ2YXJcIl0gPSBmdW5jdGlvbihhcmdzKXsgcmV0dXJuIChuZXcgd2luZG93LkRPTVBhcnNlcigpKS5wYXJzZUZyb21TdHJpbmcoXCI8Yz48ZT5cIiArIGFyZ3NbMF0gKyBcIjwvZT48L2M+XCIsIFwidGV4dC94bWxcIik7fTtcbiAgICBmdW5jdGlvbnNbXCJsaXN0XCJdID0gZnVuY3Rpb24oYXJncyl7XG5cdHZhciBiYXNlID0gKG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkpLnBhcnNlRnJvbVN0cmluZyhcIjxsPjwvbD5cIiwgXCJ0ZXh0L3htbFwiKTtcblx0Zm9yKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspe1xuXHQgICAgYmFzZS5kb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoYXJnc1tpXS5kb2N1bWVudEVsZW1lbnQuY2xvbmVOb2RlKHRydWUpKTtcblx0fVxuXHRiYXNlLmRvY3VtZW50RWxlbWVudC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZShcInNcIixTdHJpbmcoYXJncy5sZW5ndGgpKVxuXHRyZXR1cm4gYmFzZTtcbiAgICB9O1xuICAgIC8vIHZhciBjb21wYXJhdG9ycyA9IHtcIjxcIjpcImxlc3NcIixcIj5cIjpcImdyZWF0ZXJcIixcIj1cIjpcImVxXCIsXCIhPVwiOlwibmVxXCIsXCI+PVwiOlwiZ2VxXCIsXCI8PVwiOlwibGVxXCJ9O1xuICAgIC8vIGZvcih2YXIgYyBpbiBjb21wYXJhdG9ycyl7XG4gICAgLy8gXHRmdW5jdGlvbnNbY10gPSBmdW5jdGlvbihhcmdzKXtcbiAgICAvLyBcdCAgICByZXR1cm4gbWFrZV9zeW0oY29tcGFyYXRvcnNbY10sIGFyZ3MpO1xuICAgIC8vIFx0fVxuICAgIC8vIH1cbiAgICBmdW5jdGlvbnNbXCJfZGVmYXVsdFwiXSA9IGZ1bmN0aW9uKG5hbWUsIGFyZ3Mpe1xuXHRyZXR1cm4gbWFrZV9zeW0obmFtZSwgYXJncyk7XG4gICAgfVxuICAgIHZhciBhbnMgPSBHdXBweUFTVC5ldmFsKGFzdCwgZnVuY3Rpb25zKTtcbiAgICB2YXIgbmV3X2Jhc2UgPSAobmV3IHdpbmRvdy5ET01QYXJzZXIoKSkucGFyc2VGcm9tU3RyaW5nKFwiPG0+PC9tPlwiLCBcInRleHQveG1sXCIpO1xuICAgIGZvcihubiA9IGFucy5kb2N1bWVudEVsZW1lbnQuZmlyc3RDaGlsZDsgbm47IG5uID0gbm4ubmV4dFNpYmxpbmcpe1xuXHRuZXdfYmFzZS5kb2N1bWVudEVsZW1lbnQuaW5zZXJ0QmVmb3JlKG5uLmNsb25lTm9kZSh0cnVlKSxudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld19iYXNlO1xuXG59XG5cbkd1cHB5QVNULmdldF9ub2RlcyA9IGZ1bmN0aW9uKGFzdCwgbmFtZSl7XG4gICAgaWYoYXN0Lmxlbmd0aCA8IDIpIHJldHVybiBbXTtcbiAgICB2YXIgYW5zID0gW107XG4gICAgaWYoYXN0WzBdID09IG5hbWUpIGFucy5wdXNoKGFzdFsxXSk7XG4gICAgaWYoYXN0WzBdID09IFwidmFyXCIgfHwgYXN0WzBdID09IFwidmFsXCIpIHJldHVybiBhbnM7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGFzdFsxXS5sZW5ndGg7IGkrKykgYW5zID0gYW5zLmNvbmNhdChHdXBweUFTVC5nZXRfbm9kZXMoYXN0WzFdW2ldLCBuYW1lKSk7XG4gICAgcmV0dXJuIGFucztcbn1cblxuR3VwcHlBU1QuZ2V0X3ZhcnMgPSBmdW5jdGlvbihhc3Qpe1xuICAgIHZhciB2YXJzID0ge307XG4gICAgdmFyIGFucyA9IFtdO1xuICAgIHZhciBsID0gR3VwcHlBU1QuZ2V0X25vZGVzKGFzdCwgXCJ2YXJcIik7XG4gICAgZm9yKHZhciBpID0gMDsgaSA8IGwubGVuZ3RoOyBpKyspIHZhcnNbbFtpXVswXV0gPSB0cnVlO1xuICAgIGZvcih2YXIgeCBpbiB2YXJzKSBhbnMucHVzaCh4KTtcbiAgICByZXR1cm4gYW5zO1xufVxuXG5HdXBweUFTVC50b19mdW5jdGlvbiA9IGZ1bmN0aW9uKGFzdCwgZnVuY3Rpb25zKXtcbiAgICBmdW5jdGlvbnMgPSBmdW5jdGlvbnMgfHwge31cbiAgICBkZWZhdWx0cyA9IHt9XG4gICAgZGVmYXVsdHNbXCIqXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpKmFyZ3NbMV0odmFycyl9O307XG4gICAgZGVmYXVsdHNbXCIrXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpK2FyZ3NbMV0odmFycyl9O307XG4gICAgZGVmYXVsdHNbXCIvXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpL2FyZ3NbMV0odmFycyl9O307XG4gICAgZGVmYXVsdHNbXCItXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGFyZ3MubGVuZ3RoID09IDEgPyBmdW5jdGlvbih2YXJzKXtyZXR1cm4gLWFyZ3NbMF0odmFycyl9IDogZnVuY3Rpb24odmFycyl7cmV0dXJuIGFyZ3NbMF0odmFycyktYXJnc1sxXSh2YXJzKX07fTtcbiAgICBkZWZhdWx0c1tcInZhbFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXsgcmV0dXJuIGFyZ3NbMF07IH07fTtcbiAgICBkZWZhdWx0c1tcInZhclwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXsgaWYoYXJnc1swXSA9PSBcInBpXCIpIHJldHVybiBNYXRoLlBJOyBpZihhcmdzWzBdID09IFwiZVwiKSByZXR1cm4gTWF0aC5FOyByZXR1cm4gdmFyc1thcmdzWzBdXTsgfTt9O1xuICAgIGRlZmF1bHRzW1wiZXhwb25lbnRpYWxcIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gZnVuY3Rpb24odmFycyl7cmV0dXJuIGFyZ3NbMF0odmFycykqKmFyZ3NbMV0odmFycyl9O307XG4gICAgLy9kZWZhdWx0c1tcImZyYWN0aW9uXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBhcmdzWzBdKHZhcnMpL2FyZ3NbMV0odmFycyk7fTt9XG4gICAgZGVmYXVsdHNbXCJzcXVhcmVfcm9vdFwiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXtyZXR1cm4gTWF0aC5zcXJ0KGFyZ3NbMF0odmFycykpfTt9O1xuICAgIGRlZmF1bHRzW1wic2luXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBNYXRoLnNpbihhcmdzWzBdKHZhcnMpKX07fTtcbiAgICBkZWZhdWx0c1tcImNvc1wiXSA9IGZ1bmN0aW9uKGFyZ3Mpe3JldHVybiBmdW5jdGlvbih2YXJzKXtyZXR1cm4gTWF0aC5jb3MoYXJnc1swXSh2YXJzKSl9O307XG4gICAgZGVmYXVsdHNbXCJ0YW5cIl0gPSBmdW5jdGlvbihhcmdzKXtyZXR1cm4gZnVuY3Rpb24odmFycyl7cmV0dXJuIE1hdGgudGFuKGFyZ3NbMF0odmFycykpfTt9O1xuICAgIGRlZmF1bHRzW1wibG9nXCJdID0gZnVuY3Rpb24oYXJncyl7cmV0dXJuIGZ1bmN0aW9uKHZhcnMpe3JldHVybiBNYXRoLmxvZyhhcmdzWzBdKHZhcnMpKX07fTtcbiAgICBmb3IodmFyIG4gaW4gZGVmYXVsdHMpIGlmKCFmdW5jdGlvbnNbbl0pIGZ1bmN0aW9uc1tuXSA9IGRlZmF1bHRzW25dO1xuICAgIHJldHVybiB7XCJmdW5jdGlvblwiOkd1cHB5QVNULmV2YWwoYXN0LCBmdW5jdGlvbnMpLFwidmFyc1wiOkd1cHB5QVNULmdldF92YXJzKGFzdCl9O1xufVxuXG5HdXBweUFTVC5ldmFsID0gZnVuY3Rpb24oYXN0LCBmdW5jdGlvbnMsIHBhcmVudCl7XG4gICAgYW5zID0gbnVsbDtcbiAgICBpZighZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0pIGZ1bmN0aW9uc1tcIl9kZWZhdWx0XCJdID0gZnVuY3Rpb24obmFtZSwgYXJncyl7IHRocm93IFwiRnVuY3Rpb24gbm90IGltcGxlbWVudGVkOiBcIiArIG5hbWU7fVxuICAgIFxuICAgIHZhciBhcmdzID0gW11cbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgYXN0WzFdLmxlbmd0aDsgaSsrKXtcblx0aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFzdFsxXVtpXSkgPT09ICdbb2JqZWN0IEFycmF5XScpe1xuXHQgICAgYXJncy5wdXNoKEd1cHB5QVNULmV2YWwoYXN0WzFdW2ldLCBmdW5jdGlvbnMsIGFzdCkpO1xuXHR9XG5cdGVsc2V7XG5cdCAgICBhcmdzLnB1c2goYXN0WzFdW2ldKTtcblx0fVxuICAgIH1cbiAgICAvL2NvbnNvbGUubG9nKFwiRm5cIixhc3RbMF0sZnVuY3Rpb25zW2FzdFswXV0pO1xuICAgIGlmKGZ1bmN0aW9uc1thc3RbMF1dKSBhbnMgPSBmdW5jdGlvbnNbYXN0WzBdXShhcmdzLCBwYXJlbnQpO1xuICAgIGVsc2UgaWYoZnVuY3Rpb25zW1wiX2RlZmF1bHRcIl0pIGFucyA9IGZ1bmN0aW9uc1tcIl9kZWZhdWx0XCJdKGFzdFswXSwgYXJncywgcGFyZW50KTtcbiAgICBcbiAgICAvL2NvbnNvbGUubG9nKFwiRVZBTFwiLEpTT04uc3RyaW5naWZ5KGFzdCksJz0nLGFucyk7XG4gICAgcmV0dXJuIGFuc1xufVxuXG5HdXBweUFTVC5wYXJzZV9lID0gZnVuY3Rpb24odG9rZW5zKXtcbiAgICB2YXIgc3ltYm9sX3RhYmxlID0ge307XG5cbiAgICB2YXIgb3JpZ2luYWxfc3ltYm9sID0ge1xuXHRudWQ6IGZ1bmN0aW9uICgpIHsgdGhyb3cgRXJyb3IoXCJVbmRlZmluZWRcIik7IH0sXG5cdGxlZDogZnVuY3Rpb24gKGxlZnQpIHsgdGhyb3cgRXJyb3IoXCJNaXNzaW5nIG9wZXJhdG9yXCIpOyB9XG4gICAgfTtcblxuICAgIHZhciBtdWwgPSBmdW5jdGlvbihsZWZ0KXsgcmV0dXJuIFtcIipcIiwgW2xlZnQsIHRoaXMubnVkKCldXTsgfTtcbiAgICBcbiAgICB2YXIgc3ltYm9sID0gZnVuY3Rpb24gKGlkLCBicCkge1xuXHR2YXIgcyA9IHN5bWJvbF90YWJsZVtpZF07XG5cdGJwID0gYnAgfHwgMDtcblx0aWYgKHMpIHtcbiAgICAgICAgICAgIGlmIChicCA+PSBzLmxicCkge1xuXHRcdHMubGJwID0gYnA7XG4gICAgICAgICAgICB9XG5cdH0gZWxzZSB7XG4gICAgICAgICAgICBzID0gT2JqZWN0LmNyZWF0ZShvcmlnaW5hbF9zeW1ib2wpO1xuICAgICAgICAgICAgcy5pZCA9IHMudmFsdWUgPSBpZDtcbiAgICAgICAgICAgIHMubGJwID0gYnA7XG4gICAgICAgICAgICBzeW1ib2xfdGFibGVbaWRdID0gcztcblx0fVxuXHRyZXR1cm4gcztcbiAgICB9O1xuXG4gICAgc3ltYm9sKFwiKGVuZClcIik7XG5cbiAgICBzID0gc3ltYm9sKFwiKGJsYW5rKVwiLCA2MCk7XG4gICAgcy5udWQgPSBmdW5jdGlvbigpeyByZXR1cm4gW1wiYmxhbmtcIl07fTtcbiAgICBcbiAgICBzID0gc3ltYm9sKFwiKGZ1bmN0aW9uKVwiLCA2MCk7XG4gICAgcy5sZWQgPSBtdWw7XG4gICAgLy9zLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbdGhpcy52YWx1ZSwgdGhpcy5hcmdzIHx8IFtdLCB0aGlzLmt3YXJncyB8fCB7fV07fTtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbdGhpcy52YWx1ZSwgdGhpcy5hcmdzIHx8IFtdXTt9O1xuICAgIFxuICAgIHMgPSBzeW1ib2woXCIobGl0ZXJhbClcIiwgNjApO1xuICAgIHMubGVkID0gbXVsO1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFtcInZhbFwiLCBbdGhpcy52YWx1ZV1dIH07XG5cbiAgICBzID0gc3ltYm9sKFwiKHBhc3MpXCIsIDYwKTtcbiAgICBzLmxlZCA9IG11bDtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmFyZ3NbMF0gfTtcbiAgICBcbiAgICBzID0gc3ltYm9sKFwiKHZhcilcIiwgNjApO1xuICAgIHMubGVkID0gbXVsO1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFtcInZhclwiLCBbdGhpcy52YWx1ZV1dIH07XG5cbiAgICB2YXIgdG9rZW47XG4gICAgdmFyIHRva2VuX25yID0gMDtcblxuICAgIHZhciBhZHZhbmNlID0gZnVuY3Rpb24gKGlkKSB7XG5cdHZhciBhLCBvLCB0LCB2O1xuXHRpZiAoaWQgJiYgdG9rZW4uaWQgIT09IGlkKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIkV4cGVjdGVkICdcIiArIGlkICsgXCInXCIpO1xuXHR9XG5cdGlmICh0b2tlbl9uciA+PSB0b2tlbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHN5bWJvbF90YWJsZVtcIihlbmQpXCJdO1xuICAgICAgICAgICAgcmV0dXJuO1xuXHR9XG5cdHQgPSB0b2tlbnNbdG9rZW5fbnJdO1xuXHR0b2tlbl9uciArPSAxO1xuXHR2ID0gdC52YWx1ZTtcblx0dmFyIGFyZ3MgPSBudWxsO1xuXHR2YXIga3dhcmdzID0gbnVsbDtcblx0YSA9IHQudHlwZTtcblx0aWYgKGEgPT09IFwibmFtZVwiKSB7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW1wiKHZhcilcIl07XG5cdH0gZWxzZSBpZiAoYSA9PT0gXCJvcGVyYXRvclwiKSB7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW3ZdO1xuICAgICAgICAgICAgaWYgKCFvKSB7XG5cdFx0dGhyb3cgRXhjZXB0aW9uKFwiVW5rbm93biBvcGVyYXRvci5cIik7XG4gICAgICAgICAgICB9XG5cdH0gZWxzZSBpZiAoYSA9PT0gIFwicGFzc1wiKSB7XG4gICAgICAgICAgICBhID0gXCJwYXNzXCI7XG4gICAgICAgICAgICBvID0gc3ltYm9sX3RhYmxlW1wiKHBhc3MpXCJdO1xuXHQgICAgYXJncyA9IHQuYXJncztcblx0fSBlbHNlIGlmIChhID09PSAgXCJudW1iZXJcIikge1xuICAgICAgICAgICAgYSA9IFwibGl0ZXJhbFwiO1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIihsaXRlcmFsKVwiXTtcblx0fSBlbHNlIGlmIChhID09PSAgXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhID0gXCJmdW5jdGlvblwiO1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIihmdW5jdGlvbilcIl07XG5cdCAgICBhcmdzID0gdC5hcmdzO1xuXHQgICAga3dhcmdzID0gdC5rd2FyZ3M7XG5cdH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW5cIix0KTtcblx0fVxuXHR0b2tlbiA9IE9iamVjdC5jcmVhdGUobyk7XG5cdHRva2VuLnR5cGUgPSBhO1xuXHR0b2tlbi52YWx1ZSA9IHY7XG5cdGlmKGFyZ3MpIHRva2VuLmFyZ3MgPSBhcmdzO1xuXHRpZihrd2FyZ3MpIHRva2VuLmt3YXJncyA9IGt3YXJncztcblx0cmV0dXJuIHRva2VuO1xuICAgIH07XG5cblxuICAgIHZhciBleHByZXNzaW9uID0gZnVuY3Rpb24gKHJicCkge1xuXHR2YXIgbGVmdDtcblx0dmFyIHQgPSB0b2tlbjtcblx0YWR2YW5jZSgpO1xuXHRsZWZ0ID0gdC5udWQoKTtcblx0d2hpbGUgKHJicCA8IHRva2VuLmxicCkge1xuICAgICAgICAgICAgdCA9IHRva2VuO1xuICAgICAgICAgICAgYWR2YW5jZSgpO1xuICAgICAgICAgICAgbGVmdCA9IHQubGVkKGxlZnQpO1xuXHR9XG5cdHJldHVybiBsZWZ0O1xuICAgIH07XG5cbiAgICB2YXIgaW5maXggPSBmdW5jdGlvbiAoaWQsIGJwLCBsZWQpIHtcblx0dmFyIHMgPSBzeW1ib2woaWQsIGJwKTtcblx0cy5sZWQgPSBsZWQgfHwgZnVuY3Rpb24gKGxlZnQpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgW2xlZnQsIGV4cHJlc3Npb24oYnApXV07XG5cdH07XG5cdHJldHVybiBzO1xuICAgIH1cblxuICAgIFxuICAgIGluZml4KFwiPVwiLCA0MCk7XG4gICAgaW5maXgoXCIhPVwiLCA0MCk7XG4gICAgaW5maXgoXCI8XCIsIDQwKTtcbiAgICBpbmZpeChcIj5cIiwgNDApO1xuICAgIGluZml4KFwiPD1cIiwgNDApO1xuICAgIGluZml4KFwiPj1cIiwgNDApO1xuXG4gICAgaW5maXgoXCIrXCIsIDUwKTtcbiAgICBpbmZpeChcIi1cIiwgNTApO1xuICAgIGluZml4KFwiKlwiLCA2MCk7XG4gICAgaW5maXgoXCIvXCIsIDYwKTtcbiAgICB2YXIgcHJlZml4ID0gZnVuY3Rpb24gKGlkLCBudWQpIHtcblx0dmFyIHMgPSBzeW1ib2woaWQpO1xuXHRzLm51ZCA9IG51ZCB8fCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMudmFsdWUsIFtleHByZXNzaW9uKDcwKV1dO1xuXHR9O1xuXHRyZXR1cm4gcztcbiAgICB9XG5cbiAgICBwcmVmaXgoXCItXCIpO1xuICAgIHByZWZpeChcIiFcIik7XG4gICAgcHJlZml4KFwidHlwZW9mXCIpO1xuXG4gICAgaWYodG9rZW5zLmxlbmd0aCA9PSAwKSByZXR1cm4gW1wiYmxhbmtcIl07XG4gICAgXG4gICAgYWR2YW5jZSgpO1xuICAgIFxuICAgIHJldHVybiBleHByZXNzaW9uKDEwKTtcbn1cblxuXG5cbkd1cHB5QVNULnRva2VuaXNlX3RleHQgPSBmdW5jdGlvbihzKXtcbiAgICByZXR1cm4gR3VwcHlBU1QudG9rZW5pc2UocywgW1xuXHR7XCJ0eXBlXCI6XCJudW1iZXJcIiwgXCJyZVwiOlwiXlswLTkuXStcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBOdW1iZXIobSl9fSxcblx0e1widHlwZVwiOlwib3BlcmF0b3JcIiwgXCJyZVwiOlwiXighPXw+PXw8PSlcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtO319LFxuXHR7XCJ0eXBlXCI6XCJvcGVyYXRvclwiLCBcInJlXCI6XCJeW1xcLSsqLywhXigpPTw+XVwiLCBcInZhbHVlXCI6ZnVuY3Rpb24obSl7cmV0dXJuIG19fSxcblx0e1widHlwZVwiOlwibmFtZVwiLCBcInJlXCI6XCJeW2EtekEtWl9dK1wiLCBcInZhbHVlXCI6ZnVuY3Rpb24obSl7cmV0dXJuIG19fSxcblx0e1widHlwZVwiOlwiY29tbWFcIiwgXCJyZVwiOlwiXixcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG5cdHtcInR5cGVcIjpcInNwYWNlXCIsIFwicmVcIjpcIl5cXFxccytcIiwgXCJ2YWx1ZVwiOmZ1bmN0aW9uKG0pe3JldHVybiBtfX0sXG4gICAgXSk7XG59XG5cbkd1cHB5QVNULnBhcnNlX3RleHQgPSBmdW5jdGlvbih0b2tlbnMpe1xuICAgIHZhciBzeW1ib2xfdGFibGUgPSB7fTtcblxuICAgIHZhciBvcmlnaW5hbF9zeW1ib2wgPSB7XG5cdG51ZDogZnVuY3Rpb24gKCkgeyB0aHJvdyBFcnJvcihcIlVuZGVmaW5lZFwiKTsgfSxcblx0bGVkOiBmdW5jdGlvbiAobGVmdCkgeyB0aHJvdyBFcnJvcihcIk1pc3Npbmcgb3BlcmF0b3JcIik7IH1cbiAgICB9O1xuXG4gICAgdmFyIG11bCA9IGZ1bmN0aW9uKGxlZnQpeyByZXR1cm4gW1wiKlwiLCBbbGVmdCwgdGhpcy5udWQoKV1dOyB9O1xuICAgIFxuICAgIHZhciBzeW1ib2wgPSBmdW5jdGlvbiAoaWQsIGJwKSB7XG5cdHZhciBzID0gc3ltYm9sX3RhYmxlW2lkXTtcblx0YnAgPSBicCB8fCAwO1xuXHRpZiAocykge1xuICAgICAgICAgICAgaWYgKGJwID49IHMubGJwKSB7XG5cdFx0cy5sYnAgPSBicDtcbiAgICAgICAgICAgIH1cblx0fSBlbHNlIHtcbiAgICAgICAgICAgIHMgPSBPYmplY3QuY3JlYXRlKG9yaWdpbmFsX3N5bWJvbCk7XG4gICAgICAgICAgICBzLmlkID0gcy52YWx1ZSA9IGlkO1xuICAgICAgICAgICAgcy5sYnAgPSBicDtcbiAgICAgICAgICAgIHN5bWJvbF90YWJsZVtpZF0gPSBzO1xuXHR9XG5cdHJldHVybiBzO1xuICAgIH07XG5cbiAgICBzeW1ib2woXCIoZW5kKVwiKTtcblxuICAgIHMgPSBzeW1ib2woXCIoYmxhbmspXCIsIDYwKTtcbiAgICBzLm51ZCA9IGZ1bmN0aW9uKCl7IHJldHVybiBbXCJibGFua1wiXTt9O1xuICAgIFxuICAgIHMgPSBzeW1ib2woXCIobGl0ZXJhbClcIiwgNjApO1xuICAgIHMubGVkID0gbXVsO1xuICAgIHMubnVkID0gZnVuY3Rpb24oKXsgcmV0dXJuIFtcInZhbFwiLCBbdGhpcy52YWx1ZV1dIH07XG5cbiAgICB2YXIgZ2V0X2FyZ3MgPSBmdW5jdGlvbigpe1xuXHR2YXIgYXJncyA9IFtdO1xuXHRhZHZhbmNlKClcblx0aWYodG9rZW4uaWQgIT09IFwiKVwiKXtcblx0ICAgIHdoaWxlKHRydWUpe1xuXHRcdGFyZ3MucHVzaChleHByZXNzaW9uKDApKTtcblx0XHRpZiAodG9rZW4uaWQgIT09IFwiLFwiKSB7XG5cdFx0ICAgIGJyZWFrO1xuXHRcdH1cblx0XHRhZHZhbmNlKFwiLFwiKTtcblx0ICAgIH1cblx0fVxuXHRhZHZhbmNlKFwiKVwiKTtcblx0cmV0dXJuIGFyZ3M7XG4gICAgfVxuICAgIFxuICAgIHMgPSBzeW1ib2woXCIodmFyKVwiLCA2MCk7XG4gICAgcy5sZWQgPSBtdWw7XG4gICAgcy5udWQgPSBmdW5jdGlvbigpe1xuXHRpZih0b2tlbi5pZCA9PSBcIihcIil7XG5cdCAgICByZXR1cm4gW3RoaXMudmFsdWUsIGdldF9hcmdzKCldO1xuXHR9XG5cdGVsc2V7XG5cdCAgICByZXR1cm4gW1widmFyXCIsIFt0aGlzLnZhbHVlXV1cblx0fVxuICAgIH07XG4gICAgXG4gICAgdmFyIHRva2VuO1xuICAgIHZhciB0b2tlbl9uciA9IDA7XG5cbiAgICB2YXIgYWR2YW5jZSA9IGZ1bmN0aW9uIChpZCkge1xuXHR2YXIgYSwgbywgdCwgdjtcblx0aWYgKGlkICYmIHRva2VuLmlkICE9PSBpZCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBpZCArIFwiJ1wiKTtcblx0fVxuXHRpZiAodG9rZW5fbnIgPj0gdG9rZW5zLmxlbmd0aCkge1xuICAgICAgICAgICAgdG9rZW4gPSBzeW1ib2xfdGFibGVbXCIoZW5kKVwiXTtcbiAgICAgICAgICAgIHJldHVybjtcblx0fVxuXHR0ID0gdG9rZW5zW3Rva2VuX25yXTtcblx0dG9rZW5fbnIgKz0gMTtcblx0diA9IHQudmFsdWU7XG5cdHZhciBhcmdzID0gbnVsbDtcblx0dmFyIGt3YXJncyA9IG51bGw7XG5cdGEgPSB0LnR5cGU7XG5cdGlmIChhID09PSBcIm5hbWVcIikge1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVtcIih2YXIpXCJdO1xuXHR9IGVsc2UgaWYgKGEgPT09IFwib3BlcmF0b3JcIikge1xuICAgICAgICAgICAgbyA9IHN5bWJvbF90YWJsZVt2XTtcbiAgICAgICAgICAgIGlmICghbykge1xuXHRcdHRocm93IEVycm9yKFwiVW5rbm93biBvcGVyYXRvci5cIik7XG4gICAgICAgICAgICB9XG5cdH0gZWxzZSBpZiAoYSA9PT0gIFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGEgPSBcImxpdGVyYWxcIjtcbiAgICAgICAgICAgIG8gPSBzeW1ib2xfdGFibGVbXCIobGl0ZXJhbClcIl07XG5cdH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcihcIlVuZXhwZWN0ZWQgdG9rZW5cIix0KTtcblx0fVxuXHR0b2tlbiA9IE9iamVjdC5jcmVhdGUobyk7XG5cdHRva2VuLnR5cGUgPSBhO1xuXHR0b2tlbi52YWx1ZSA9IHY7XG5cdGlmKGFyZ3MpIHRva2VuLmFyZ3MgPSBhcmdzO1xuXHQvL2NvbnNvbGUubG9nKFwiQURWRFwiLEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG5cdHJldHVybiB0b2tlbjtcbiAgICB9O1xuXG5cbiAgICB2YXIgZXhwcmVzc2lvbiA9IGZ1bmN0aW9uIChyYnApIHtcblx0dmFyIGxlZnQ7XG5cdHZhciB0ID0gdG9rZW47XG5cdC8vY29uc29sZS5sb2coXCJUMVwiLEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG5cdGFkdmFuY2UoKTtcblx0Ly9jb25zb2xlLmxvZyhcIlQyXCIsSlNPTi5zdHJpbmdpZnkodG9rZW4pKTtcblx0bGVmdCA9IHQubnVkKCk7XG5cdHdoaWxlIChyYnAgPCB0b2tlbi5sYnApIHtcbiAgICAgICAgICAgIHQgPSB0b2tlbjtcbiAgICAgICAgICAgIGFkdmFuY2UoKTtcblx0ICAgIC8vY29uc29sZS5sb2coXCJSQlwiLEpTT04uc3RyaW5naWZ5KHRva2VuKSk7XG4gICAgICAgICAgICBsZWZ0ID0gdC5sZWQobGVmdCk7XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhcIlBPV1wiLCByYnAsIHRva2VuLmlkLCB0b2tlbi5sYnApO1xuXHRyZXR1cm4gbGVmdDtcbiAgICB9O1xuXG4gICAgdmFyIGluZml4ID0gZnVuY3Rpb24gKGlkLCBicCwgbGVkKSB7XG5cdHZhciBzID0gc3ltYm9sKGlkLCBicCk7XG5cdHMubGVkID0gbGVkIHx8IGZ1bmN0aW9uIChsZWZ0KSB7XG4gICAgICAgICAgICByZXR1cm4gW3RoaXMudmFsdWUsIFtsZWZ0LCBleHByZXNzaW9uKGJwKV1dO1xuXHR9O1xuXHRyZXR1cm4gcztcbiAgICB9XG5cbiAgICBpbmZpeChcIj1cIiwgNDApO1xuICAgIGluZml4KFwiIT1cIiwgNDApO1xuICAgIGluZml4KFwiPFwiLCA0MCk7XG4gICAgaW5maXgoXCI+XCIsIDQwKTtcbiAgICBpbmZpeChcIjw9XCIsIDQwKTtcbiAgICBpbmZpeChcIj49XCIsIDQwKTtcblxuICAgIGluZml4KFwiK1wiLCA1MCk7XG4gICAgaW5maXgoXCItXCIsIDUwKTtcbiAgICBpbmZpeChcIipcIiwgNjApO1xuICAgIGluZml4KFwiL1wiLCA2MCk7XG4gICAgXG4gICAgaW5maXgoXCIhXCIsIDcwLCBmdW5jdGlvbihsZWZ0KXtcblx0cmV0dXJuIFtcImZhY3RvcmlhbFwiLCBbbGVmdF1dO1xuICAgIH0pO1xuICAgIFxuICAgIGluZml4KFwiXlwiLCA3MCwgZnVuY3Rpb24obGVmdCl7XG5cdHJldHVybiBbXCJleHBvbmVudGlhbFwiLCBbbGVmdCwgZXhwcmVzc2lvbig3MCldXTtcbiAgICB9KTtcbiAgICBcbiAgICBpbmZpeChcIihcIiwgODAsIG11bCk7XG5cbiAgICBzeW1ib2woXCIoXCIpLm51ZCA9IGZ1bmN0aW9uKCl7XG5cdHZhciBhbnMgPSBleHByZXNzaW9uKDApO1xuXHRhZHZhbmNlKFwiKVwiKTtcblx0cmV0dXJuIGFucztcbiAgICB9XG4gICAgc3ltYm9sKFwiKVwiKTtcbiAgICBzeW1ib2woXCIsXCIpO1xuICAgIFxuICAgIHZhciBwcmVmaXggPSBmdW5jdGlvbiAoaWQsIG51ZCkge1xuXHR2YXIgcyA9IHN5bWJvbChpZCk7XG5cdHMubnVkID0gbnVkIHx8IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBbdGhpcy52YWx1ZSwgW2V4cHJlc3Npb24oNzApXV07XG5cdH07XG5cdHJldHVybiBzO1xuICAgIH1cblxuICAgIHByZWZpeChcIi1cIik7XG5cbiAgICBpZih0b2tlbnMubGVuZ3RoID09IDApIHJldHVybiBbXCJibGFua1wiXTtcbiAgICBcbiAgICBhZHZhbmNlKCk7XG4gICAgXG4gICAgcmV0dXJuIGV4cHJlc3Npb24oMTApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEd1cHB5QVNUO1xuIiwiR3VwcHlBU1QgPSByZXF1aXJlKCcuL2d1cHB5X2FzdC5qcycpO1xuXG4vKipcbiAgIEBjbGFzc1xuICAgQGNsYXNzZGVzYyBBIGNsYXNzIHJlcHJlc2VudGluZyBhIEd1cHB5IGRvY3VtZW50XG4gICBAcGFyYW0ge3N0cmluZ30gW2RvYz08bT48ZT48L2U+PC9tPl0gLSBBbiBYTUwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZG9jdW1lbnRcbiAgIEBjb25zdHJ1Y3RvciBcbiAqL1xudmFyIEd1cHB5RG9jID0gZnVuY3Rpb24oZG9jKXtcbiAgICBkb2MgPSBkb2MgfHwgXCI8bT48ZT48L2U+PC9tPlwiO1xuICAgIHRoaXMuc2V0X2NvbnRlbnQoZG9jKTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLmlzX3NtYWxsID0gZnVuY3Rpb24obm4pe1xuICAgIHZhciBuID0gbm4ucGFyZW50Tm9kZTtcbiAgICB3aGlsZShuICE9IG51bGwgJiYgbi5ub2RlTmFtZSAhPSAnbScpe1xuXHRpZihuLmdldEF0dHJpYnV0ZShcInNtYWxsXCIpID09IFwieWVzXCIpIHJldHVybiB0cnVlO1xuXHRuID0gbi5wYXJlbnROb2RlXG5cdHdoaWxlKG4gIT0gbnVsbCAmJiBuLm5vZGVOYW1lICE9ICdjJykgbiA9IG4ucGFyZW50Tm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUuZW5zdXJlX3RleHRfbm9kZXMgPSBmdW5jdGlvbigpe1xuICAgIHZhciBsID0gdGhpcy5iYXNlLmdldEVsZW1lbnRzQnlUYWdOYW1lKFwiZVwiKTtcbiAgICBmb3IodmFyIGkgPSAwOyBpIDwgbC5sZW5ndGg7IGkrKyl7XG5cdGlmKCEobFtpXS5maXJzdENoaWxkKSkgbFtpXS5hcHBlbmRDaGlsZCh0aGlzLmJhc2UuY3JlYXRlVGV4dE5vZGUoXCJcIikpO1xuICAgIH1cbn1cblxuLyoqIFxuICAgIENoZWNrIGlmIGRvY3VtZW50IGlzIGVtcHR5XG4gICAgQG1lbWJlcm9mIEd1cHB5RG9jXG4gICAgQHJldHVybnMge2Jvb2xlYW59XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLmlzX2JsYW5rID0gZnVuY3Rpb24oKXtcbiAgICBpZih0aGlzLmJhc2UuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJmXCIpLmxlbmd0aCA+IDApIHJldHVybiBmYWxzZTtcbiAgICB2YXIgbCA9IHRoaXMuYmFzZS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImVcIik7XG4gICAgaWYobC5sZW5ndGggPT0gMSAmJiAoIShsWzBdLmZpcnN0Q2hpbGQpIHx8IGxbMF0uZmlyc3RDaGlsZC50ZXh0Q29udGVudCA9PSBcIlwiKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuXG5cbi8qKiBcbiAgICBHZXQgdGhlIGRvY3VtZW50IGFzIGEgRE9NIG9iamVjdFxuICAgIEBtZW1iZXJvZiBHdXBweURvY1xuICAgIEByZXR1cm5zIHtFbGVtZW50fVxuKi9cbkd1cHB5RG9jLnByb3RvdHlwZS5yb290ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdGhpcy5iYXNlLmRvY3VtZW50RWxlbWVudDtcbn1cblxuLyoqIFxuICAgIEdldCB0aGUgY29udGVudCBvZiB0aGUgZG9jdW1lbnQgYXMgYSBzdHJpbmdcbiAgICBAbWVtYmVyb2YgR3VwcHlEb2NcbiAgICBAcGFyYW0ge3N0cmluZ30gdCAtIFRoZSByZW5kZXJpbmcgbWV0aG9kIHRvIHVzZSAoXCJsYXRleFwiLCBcInRleHRcIiwgXCJhc3RcIiAoZm9yIHN5bnRheCB0cmVlKSwgb3IgXCJ4bWxcIiAoZm9yIGludGVybmFsIFhNTCByZXByZXNlbnRhdGlvbikpXG4gICAgQHJldHVybnMge3N0cmluZ31cbiovXG5HdXBweURvYy5wcm90b3R5cGUuZ2V0X2NvbnRlbnQgPSBmdW5jdGlvbih0LHIpe1xuICAgIGlmKHQgPT0gXCJ4bWxcIikgcmV0dXJuIChuZXcgWE1MU2VyaWFsaXplcigpKS5zZXJpYWxpemVUb1N0cmluZyh0aGlzLmJhc2UpO1xuICAgIGVsc2UgaWYodCA9PSBcImFzdFwiKSByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5zeW50YXhfdHJlZSgpKTtcbiAgICBlbHNlIGlmKHQgPT0gXCJ0ZXh0XCIpIHJldHVybiBHdXBweUFTVC50b190ZXh0KHRoaXMuc3ludGF4X3RyZWUoKSk7XG4gICAgZWxzZSBpZih0ID09IFwiZnVuY3Rpb25cIikgcmV0dXJuIEd1cHB5QVNULnRvX2Z1bmN0aW9uKHRoaXMuc3ludGF4X3RyZWUoKSk7XG4gICAgZWxzZSBpZih0ID09IFwiZXFuc1wiKSByZXR1cm4gR3VwcHlBU1QudG9fZXFsaXN0KHRoaXMuc3ludGF4X3RyZWUoKSk7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5tYW51YWxfcmVuZGVyKHQsdGhpcy5yb290KCkscik7XG59XG5cbkd1cHB5RG9jLnByb3RvdHlwZS5pbXBvcnRfdGV4dCA9IGZ1bmN0aW9uKHRleHQsIHN5bXMsIHMybil7XG4gICAgdmFyIHRva2VucyA9IEd1cHB5QVNULnRva2VuaXNlX3RleHQodGV4dCk7XG4gICAgY29uc29sZS5sb2coXCJUT0tFTlNcIixKU09OLnN0cmluZ2lmeSh0b2tlbnMpKTtcbiAgICB2YXIgYXN0ID0gR3VwcHlBU1QucGFyc2VfdGV4dCh0b2tlbnMpO1xuICAgIGNvbnNvbGUubG9nKFwiQVNUXCIsSlNPTi5zdHJpbmdpZnkoYXN0KSk7XG4gICAgdGhpcy5pbXBvcnRfYXN0KGFzdCwgc3ltcywgczJuKTtcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLmltcG9ydF9hc3QgPSBmdW5jdGlvbihhc3QsIHN5bXMsIHMybil7XG4gICAgc3ltcyA9IHN5bXMgfHwgR3VwcHlTeW1ib2xzLnN5bWJvbHM7XG4gICAgczJuID0gczJuIHx8IEd1cHB5U3ltYm9scy5zeW1ib2xfdG9fbm9kZTtcbiAgICB2YXIgZG9jID0gR3VwcHlBU1QudG9feG1sKGFzdCwgc3ltcywgczJuKTtcbiAgICB0aGlzLmJhc2UgPSBkb2M7XG4gICAgdGhpcy5lbnN1cmVfdGV4dF9ub2RlcygpO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUuc3ludGF4X3RyZWUgPSBmdW5jdGlvbihuKXtcbiAgICBuID0gbiB8fCB0aGlzLnJvb3QoKVxuICAgIGlmKG4ubm9kZU5hbWUgPT0gXCJlXCIpe1xuXHRjb25zb2xlLmxvZyhcIlNob3VsZCBuZXZlciBoYXBwZW5cIik7XG5cdC8vYW5zID0gbi5maXJzdENoaWxkLnRleHRDb250ZW50O1xuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJmXCIpe1xuXHR2YXIgYW5zID0ge1wiYXJnc1wiOltdLCBcImt3YXJnc1wiOnt9fTtcblx0YW5zWyd2YWx1ZSddID0gbi5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpO1xuXHRhbnNbJ3R5cGUnXSA9IFwiZnVuY3Rpb25cIjtcblx0aWYobi5oYXNBdHRyaWJ1dGUoXCJhc3RfdmFsdWVcIikpIGFuc1sndmFsdWUnXSA9IG4uZ2V0QXR0cmlidXRlKFwiYXN0X3ZhbHVlXCIpO1xuXHRpZihuLmhhc0F0dHJpYnV0ZShcImFzdF90eXBlXCIpKSBhbnNbJ3R5cGUnXSA9IG4uZ2V0QXR0cmlidXRlKFwiYXN0X3R5cGVcIik7XG5cdGVsc2UgaWYobi5nZXRBdHRyaWJ1dGUoXCJjaGFyXCIpID09IFwieWVzXCIpIGFuc1sndHlwZSddID0gXCJuYW1lXCI7XG5cdFxuXHR2YXIgaXRlcmF0b3IgPSB0aGlzLnhwYXRoX2xpc3QoXCIuLypbbmFtZSgpPSdjJyBvciBuYW1lKCk9J2wnXVwiLCBuKVxuXHRmb3IodmFyIG5uID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKTsgbm4gIT0gbnVsbDsgbm4gPSBpdGVyYXRvci5pdGVyYXRlTmV4dCgpKXtcblx0ICAgIC8vaWYobm4uaGFzQXR0cmlidXRlKFwibmFtZVwiKSkgYW5zLmt3YXJnc1tubi5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpXSA9IHRoaXMuc3ludGF4X3RyZWUobm4pXG5cdCAgICAvL2Vsc2UgYW5zLmFyZ3MucHVzaCh0aGlzLnN5bnRheF90cmVlKG5uKSlcblx0ICAgIGFucy5hcmdzLnB1c2godGhpcy5zeW50YXhfdHJlZShubikpXG5cdH1cblx0Ly9jb25zb2xlLmxvZyhcIkZcIixKU09OLnN0cmluZ2lmeShhbnMpKVxuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJsXCIpe1xuXHRhbnMgPSBbXTtcblx0Zm9yKHZhciBubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZyl7XG5cdCAgICBhbnMucHVzaCh0aGlzLnN5bnRheF90cmVlKG5uKSk7XG5cdH1cblx0YW5zID0gW1wibGlzdFwiLGFuc107XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImNcIiB8fCBuLm5vZGVOYW1lID09IFwibVwiKXtcblx0aWYobi5oYXNBdHRyaWJ1dGUoXCJtb2RlXCIpICYmIG4uZ2V0QXR0cmlidXRlKFwibW9kZVwiKSA9PSBcInRleHRcIil7XG5cdCAgICBhbnMgPSBuLmZpcnN0Q2hpbGQuZmlyc3RDaGlsZC50ZXh0Q29udGVudDtcblx0fVxuXHRlbHNle1xuXHQgICAgdmFyIHRva2VucyA9IFtdXG5cdCAgICBmb3IodmFyIG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcblx0XHRpZihubi5ub2RlTmFtZSA9PSBcImVcIil7XG5cdFx0ICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQoR3VwcHlBU1QudG9rZW5pc2VfZShubi5maXJzdENoaWxkLnRleHRDb250ZW50KSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYobm4ubm9kZU5hbWUgPT0gXCJmXCIpe1xuXHRcdCAgICB0b2tlbnMucHVzaCh0aGlzLnN5bnRheF90cmVlKG5uKSk7XG5cdFx0fVxuXHQgICAgfVxuXHQgICAgLy9jb25zb2xlLmxvZyhcIlRPS1wiLHRva2Vucyk7XG5cdCAgICBhbnMgPSBHdXBweUFTVC5wYXJzZV9lKHRva2Vucyk7XG5cdH1cbiAgICB9XG4gICAgcmV0dXJuIGFucztcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLnhwYXRoX25vZGUgPSBmdW5jdGlvbih4cGF0aCwgbm9kZSl7XG4gICAgbm9kZSA9IG5vZGUgfHwgdGhpcy5yb290KClcbiAgICByZXR1cm4gdGhpcy5iYXNlLmV2YWx1YXRlKHhwYXRoLCBub2RlLCBudWxsLCBYUGF0aFJlc3VsdC5GSVJTVF9PUkRFUkVEX05PREVfVFlQRSwgbnVsbCkuc2luZ2xlTm9kZVZhbHVlO1xufVxuXG5HdXBweURvYy5wcm90b3R5cGUueHBhdGhfbGlzdCA9IGZ1bmN0aW9uKHhwYXRoLCBub2RlKXtcbiAgICBub2RlID0gbm9kZSB8fCB0aGlzLnJvb3QoKVxuICAgIHJldHVybiB0aGlzLmJhc2UuZXZhbHVhdGUoeHBhdGgsIG5vZGUsIG51bGwsIFhQYXRoUmVzdWx0Lk9SREVSRURfTk9ERV9JVEVSQVRPUl9UWVBFLCBudWxsKTtcbn1cblxuLyoqIFxuICAgIEdldCB0aGUgbmFtZXMgb2Ygc3ltYm9scyB1c2VkIGluIHRoaXMgZG9jdW1lbnRcbiAgICBAbWVtYmVyb2YgR3VwcHlEb2NcbiAgICBAcGFyYW0ge3N0cmluZ1tdfSBbZ3JvdXBzXSAtIEEgbGlzdCBvZiBncm91cHMgeW91IHdhbnQgc3RyaW5ncyBmb3JcbiAgICBAcmV0dXJucyB7c3RyaW5nW119XG4qL1xuR3VwcHlEb2MucHJvdG90eXBlLmdldF9zeW1ib2xzID0gZnVuY3Rpb24oZ3JvdXBzKXtcbiAgICB2YXIgdHlwZXMgPSB7fTtcbiAgICB2YXIgYW5zID0gW107XG4gICAgdmFyIGl0ZXJhdG9yID0gZ3JvdXBzID8gdGhpcy54cGF0aF9saXN0KFwiLy9mXCIpIDogdGhpcy54cGF0aF9saXN0KFwiLy9mW0Bncm91cD0nXCIrZ3JvdXBzW2ldK1wiJ11cIik7XG4gICAgZm9yKHZhciBubiA9IGl0ZXJhdG9yLml0ZXJhdGVOZXh0KCk7IG5uICE9IG51bGw7IG5uID0gaXRlcmF0b3IuaXRlcmF0ZU5leHQoKSlcblx0dHlwZXNbbm4uZ2V0QXR0cmlidXRlKFwidHlwZVwiKV0gPSB0cnVlO1xuICAgIGZvcih2YXIgdCBpbiB0eXBlcylcblx0YW5zLnB1c2godCk7XG4gICAgcmV0dXJuIGFucztcbn1cblxuLyoqIFxuICAgIFNldCB0aGUgY29udGVudCBvZiB0aGUgZG9jdW1lbnRcbiAgICBAbWVtYmVyb2YgR3VwcHlEb2NcbiAgICBAcGFyYW0ge3N0cmluZ30geG1sX2RhdGEgLSBBbiBYTUwgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY29udGVudCBvZiB0aGUgZG9jdW1lbnRcbiovXG5HdXBweURvYy5wcm90b3R5cGUuc2V0X2NvbnRlbnQgPSBmdW5jdGlvbih4bWxfZGF0YSl7XG4gICAgdGhpcy5iYXNlID0gKG5ldyB3aW5kb3cuRE9NUGFyc2VyKCkpLnBhcnNlRnJvbVN0cmluZyh4bWxfZGF0YSwgXCJ0ZXh0L3htbFwiKTtcbiAgICB0aGlzLmVuc3VyZV90ZXh0X25vZGVzKCk7XG59XG5cbkd1cHB5RG9jLmJyYWNrZXRfeHBhdGggPSBcIihjb3VudCguLyopICE9IDEgYW5kIG5vdCBcXFxuXHRcdCAgICAgICAgICAoIFxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQoLi9lKT0yIGFuZCBcXFxuXHRcdFx0ICAgIGNvdW50KC4vZik9MSBhbmQgXFxcblx0XHRcdCAgICBjb3VudCguL2Vbc3RyaW5nLWxlbmd0aCh0ZXh0KCkpPTBdKT0yIGFuZCBcXFxuXHRcdFx0ICAgICggXFxcblx0XHRcdCAgICAgIChcXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudCguL2YvYyk9MSBhbmRcXFxuXHRcdFx0ICAgICAgICBjb3VudCguL2YvY1tAaXNfYnJhY2tldD0neWVzJ10pPTFcXFxuXHRcdFx0ICAgICAgKVxcXG5cdFx0XHQgICAgICBvclxcXG5cdFx0XHQgICAgICAoXFxcblx0XHRcdCAgICAgICAgZi9AY2hhcj0neWVzJyBhbmQgXFxcblx0XHRcdFx0Y291bnQoLi9lW0BjdXJyZW50PSd5ZXMnXSk9MCBhbmQgXFxcblx0XHRcdFx0Y291bnQoLi9lW0B0ZW1wPSd5ZXMnXSk9MCBcXFxuXHRcdFx0ICAgICAgKVxcXG5cdFx0XHQgICAgKVxcXG5cdFx0XHQgIClcXFxuXHRcdFx0KSAgXFxcblx0XHRcdG9yXFxcblx0XHQgICAgICAgIChcXFxuXHRcdFx0ICBjb3VudCguLyopID0gMSBhbmQgXFxcblx0XHRcdCAgc3RyaW5nLWxlbmd0aCguL2UvdGV4dCgpKSAhPSAxIGFuZCBcXFxuXHRcdFx0ICBudW1iZXIoLi9lL3RleHQoKSkgIT0gLi9lL3RleHQoKSBcXFxuXHRcdFx0KSBcXFxuXHRcdFx0b3IgXFxcblx0XHQgICAgICAgICggXFxcblx0XHRcdCAgY291bnQoLi8qKSA9IDEgYW5kIFxcXG5cdFx0XHQgIC4vZS9AY3VycmVudCA9ICd5ZXMnIFxcXG5cdFx0XHQpIFxcXG5cdFx0XHRvciBcXFxuXHRcdCAgICAgICAgKCBcXFxuXHRcdFx0ICBjb3VudCguLyopID0gMSBhbmQgXFxcblx0XHRcdCAgLi9lL0B0ZW1wID0gJ3llcycgXFxcblx0XHRcdClcIlxuXG5HdXBweURvYy5wcm90b3R5cGUubWFudWFsX3JlbmRlciA9IGZ1bmN0aW9uKHQsbixyKXtcbiAgICB2YXIgYW5zID0gXCJcIjtcbiAgICBpZihuLm5vZGVOYW1lID09IFwiZVwiKXtcblx0aWYodCA9PSBcImxhdGV4XCIgJiYgcil7XG5cdCAgICBhbnMgPSBuLmdldEF0dHJpYnV0ZShcInJlbmRlclwiKTtcblx0fVxuXHRlbHNlIGlmKHQgPT0gXCJ0ZXh0XCIpe1xuXHQgICAgYW5zID0gbi5maXJzdENoaWxkLnRleHRDb250ZW50O1xuXHQgICAgaWYobi5wcmV2aW91c1NpYmxpbmcgJiYgbi5uZXh0U2libGluZyAmJiBhbnMgPT0gXCJcIilcblx0XHRhbnMgPSBcIiAqIFwiO1xuXHQgICAgZWxzZSB7XG5cdFx0YW5zID0gYW5zLnJlcGxhY2UoLyguKShbXmEtekEtWjAtOS5dKSguKS9nLFwiJDEgJDIgJDNcIik7XG5cdFx0YW5zID0gYW5zLnJlcGxhY2UoLyhbYS16QS1aXSkoPz1cXC4pL2csXCIkMSAqIFwiKTtcblx0XHRhbnMgPSBhbnMucmVwbGFjZSgvKFxcLikoPz1bYS16QS1aXSkvZyxcIiQxICogXCIpO1xuXHRcdGFucyA9IGFucy5yZXBsYWNlKC8oW2EtekEtWl0pKD89W2EtekEtWjAtOV0pL2csXCIkMSAqIFwiKTtcblx0XHRhbnMgPSBhbnMucmVwbGFjZSgvKFthLXpBLVowLTldKSg/PVthLXpBLVpdKS9nLFwiJDEgKiBcIik7XG5cdFx0aWYobi5wcmV2aW91c1NpYmxpbmcgJiYgbi5wcmV2aW91c1NpYmxpbmcuZ2V0QXR0cmlidXRlKFwiZ3JvdXBcIikgIT0gXCJvcGVyYXRpb25zXCIpIGFucyA9IGFucy5yZXBsYWNlKC9eKFthLXpBLVowLTldKS9nLFwiICogJDFcIik7XG5cdFx0aWYobi5uZXh0U2libGluZyAmJiBuLm5leHRTaWJsaW5nLmdldEF0dHJpYnV0ZShcImdyb3VwXCIpICE9IFwib3BlcmF0aW9uc1wiKSBhbnMgPSBhbnMucmVwbGFjZSgvKFthLXpBLVowLTldKSQvZyxcIiQxICogXCIpO1xuXHRcdGFucyA9IFwiIFwiK2FucytcIiBcIjtcblx0ICAgIH1cblx0fVxuXHRlbHNle1xuXHQgICAgYW5zID0gbi5maXJzdENoaWxkLnRleHRDb250ZW50O1xuXHR9XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImZcIil7XG5cdHZhciByZWFsX3R5cGUgPSAodCA9PSBcImxhdGV4XCIgJiYgdGhpcy5pc19zbWFsbChuKSkgPyBcInNtYWxsX2xhdGV4XCIgOiB0O1xuXHR2YXIgbm4gPSB0aGlzLnhwYXRoX25vZGUoXCIuL2JbQHA9J1wiK3JlYWxfdHlwZStcIiddXCIsIG4pIHx8IHRoaXMueHBhdGhfbm9kZShcIi4vYltAcD0nXCIrdCtcIiddXCIsIG4pO1xuXHRpZihubikgYW5zID0gdGhpcy5tYW51YWxfcmVuZGVyKHQsbm4scik7XG4gICAgfVxuICAgIGVsc2UgaWYobi5ub2RlTmFtZSA9PSBcImJcIil7XG5cdHZhciBjcyA9IFtdXG5cdHZhciBpID0gMTtcblx0dmFyIHBhciA9IG4ucGFyZW50Tm9kZTtcblx0Zm9yKHZhciBubiA9IHBhci5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKVxuXHQgICAgaWYobm4ubm9kZU5hbWUgPT0gXCJjXCIgfHwgbm4ubm9kZU5hbWUgPT0gXCJsXCIpIGNzW2krK10gPSB0aGlzLm1hbnVhbF9yZW5kZXIodCxubixyKTtcblx0Zm9yKHZhciBubiA9IG4uZmlyc3RDaGlsZDsgbm4gIT0gbnVsbDsgbm4gPSBubi5uZXh0U2libGluZyl7XG5cdCAgICBpZihubi5ub2RlVHlwZSA9PSAzKSBhbnMgKz0gbm4udGV4dENvbnRlbnQ7XG5cdCAgICBlbHNlIGlmKG5uLm5vZGVUeXBlID09IDEpe1xuXHRcdGlmKG5uLmhhc0F0dHJpYnV0ZShcImRcIikpe1xuXHRcdCAgICB2YXIgZGltID0gcGFyc2VJbnQobm4uZ2V0QXR0cmlidXRlKFwiZFwiKSk7XG5cdFx0ICAgIHZhciBqb2luZXIgPSBmdW5jdGlvbihkLGwpe1xuXHRcdFx0aWYoZCA+IDEpIGZvcih2YXIgayA9IDA7IGsgPCBsLmxlbmd0aDsgaysrKSBsW2tdID0gam9pbmVyKGQtMSxsW2tdKTtcblx0XHRcdHJldHVybiBsLmpvaW4obm4uZ2V0QXR0cmlidXRlKCdzZXAnKyhkLTEpKSk7XG5cdFx0ICAgIH1cblx0XHQgICAgYW5zICs9IGpvaW5lcihkaW0sY3NbcGFyc2VJbnQobm4uZ2V0QXR0cmlidXRlKFwicmVmXCIpKV0pO1xuXHRcdH1cblx0XHRlbHNlIGFucyArPSBjc1twYXJzZUludChubi5nZXRBdHRyaWJ1dGUoXCJyZWZcIikpXTtcblx0ICAgIH1cblx0fVxuICAgIH1cbiAgICBlbHNlIGlmKG4ubm9kZU5hbWUgPT0gXCJsXCIpe1xuXHRhbnMgPSBbXTtcblx0dmFyIGkgPSAwO1xuXHRmb3IodmFyIG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKXtcblx0ICAgIGFuc1tpKytdID0gdGhpcy5tYW51YWxfcmVuZGVyKHQsbm4scik7XG5cdH1cbiAgICB9XG4gICAgZWxzZSBpZihuLm5vZGVOYW1lID09IFwiY1wiIHx8IG4ubm9kZU5hbWUgPT0gXCJtXCIpe1xuXHRmb3IodmFyIG5uID0gbi5maXJzdENoaWxkOyBubiAhPSBudWxsOyBubiA9IG5uLm5leHRTaWJsaW5nKVxuXHQgICAgYW5zICs9IHRoaXMubWFudWFsX3JlbmRlcih0LG5uLHIpO1xuXHRpZih0ID09IFwibGF0ZXhcIiAmJlxuICAgICAgICAgICBuLmdldEF0dHJpYnV0ZShcImJyYWNrZXRcIikgPT0gXCJ5ZXNcIiAmJlxuXHQgICB0aGlzLmJhc2UuZXZhbHVhdGUoR3VwcHlEb2MuYnJhY2tldF94cGF0aCwgbiwgbnVsbCxcblx0XHRcdCBYUGF0aFJlc3VsdC5CT09MRUFOX1RZUEUsIG51bGwpLmJvb2xlYW5WYWx1ZSl7IFxuXHQgICAgYW5zID0gXCJcXFxcbGVmdChcIithbnMrXCJcXFxccmlnaHQpXCI7XG5cdH1cbiAgICB9XG4gICAgcmV0dXJuIGFucztcbn1cblxuR3VwcHlEb2MucHJvdG90eXBlLnBhdGhfdG8gPSBmdW5jdGlvbihuKXtcbiAgICB2YXIgbmFtZSA9IG4ubm9kZU5hbWU7XG4gICAgaWYobmFtZSA9PSBcIm1cIikgcmV0dXJuIFwiZ3VwcHlfbG9jX21cIjtcbiAgICB2YXIgbnMgPSAwO1xuICAgIGZvcih2YXIgbm4gPSBuOyBubiAhPSBudWxsOyBubiA9IG5uLnByZXZpb3VzU2libGluZykgaWYobm4ubm9kZVR5cGUgPT0gMSAmJiBubi5ub2RlTmFtZSA9PSBuYW1lKSBucysrO1xuICAgIHJldHVybiB0aGlzLnBhdGhfdG8obi5wYXJlbnROb2RlKStcIl9cIituYW1lK1wiXCIrbnM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gR3VwcHlEb2M7XG4iXX0=
